
/*
Gaigen 0.99, Copyright (c) 2001-2003, University of Amsterdam

Copying, use and development for education and research purposes 
permitted as long as this license is not removed from the files.

All rights for commercial use reserved; for more information
contact Daniel Fontijne (fontijne@science.uva.nl)

This software is unsupported.
*/

/*
Header file l3ga.h, generated by Gaigen 0.99 on Tue Jun 12 19:59:00 2012
*/
#ifndef _l3ga_H_
#define _l3ga_H_

#include <stdio.h>
#include <stdlib.h>

// undefine all definitions possibly made in other gaigen header file
// This is important when multiple algebras are used in the same application
#undef GAIM_PRODUCT_GP
#undef GAIM_PRODUCT_LCONT
#undef GAIM_PRODUCT_HIP
#undef GAIM_PRODUCT_MHIP
#undef GAIM_PRODUCT_RCONT
#undef GAIM_PRODUCT_OP
#undef GAIM_PRODUCT_SCP
#undef GAIM_PRODUCT_GPEM
#undef GAIM_PRODUCT_LCEM
#undef GAIM_PRODUCT_SCPEM
#undef GAIM_PRODUCT_IGP
#undef GAIM_PRODUCT_GP_EM
#undef GAIM_PRODUCT_LCONT_EM
#undef GAIM_PRODUCT_OM
#undef GAIM_FUNCTION_GRADEINVOLUTION
#undef GAIM_FUNCTION_REVERSE
#undef GAIM_FUNCTION_NEGATE
#undef GAIM_FUNCTION_ADD
#undef GAIM_FUNCTION_SUBSTRACT
#undef GAIM_FUNCTION_NORM_A
#undef GAIM_FUNCTION_NORMALIZE
#undef GAIM_FUNCTION_TAKEGRADE
#undef GAIM_FUNCTION_VERSORINVERSE
#undef GAIM_FUNCTION_GENERALINVERSE
#undef GAIM_FUNCTION_SPINORPRODUCT
#undef GAIM_FUNCTION_CLIFFORDCONJUGATE
#undef GAIM_FUNCTION_LOUNESTOINVERSE
#undef GAIM_FUNCTION_HIGHESTGRADE
#undef GAIM_FUNCTION_GRADE
#undef GAIM_FUNCTION_OUTERMORPHISM
#undef GAIM_FUNCTION_PROJECT
#undef GAIM_FUNCTION_MEETJOIN
#undef GAIM_FUNCTION_RANDOM
#undef GAIM_FUNCTION_RECIPROCALFRAME
#undef GAIM_FUNCTION_PROFILE
#undef GAIM_FUNCTION_FACTOR
#undef GAIM_FUNCTION_FASTTEMPVAR
#undef GAIM_FUNCTION_FASTDUAL
#undef GAIM_FUNCTION_MULTIVECTORTYPE
#undef GAIM_FUNCTION_PARSESTRING
#undef GAIM_FUNCTION_NAMESPACE
#undef GAIM_FUNCTION_USINGNAMESPACE
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_FUNCTION_UNDEFINED
#undef GAIM_INVERSEPSEUDOSCALAR
#undef GAIM_PSEUDOSCALAR
#undef GAIM_FLOAT
#undef GAIM_DOUBLE
#undef GAIM_CLASSNAME
#undef GAIM_OM_CLASSNAME
#undef GAIM_CONSTRUCTOR_1_COOR
#undef GAIM_CONSTRUCTOR_2_COOR
#undef GAIM_CONSTRUCTOR_3_COOR
#undef GAIM_CONSTRUCTOR_4_COOR
#undef GAIM_CONSTRUCTOR_5_COOR
#undef GAIM_CONSTRUCTOR_6_COOR
#undef GAIM_CONSTRUCTOR_7_COOR
#undef GAIM_CONSTRUCTOR_8_COOR

// what functions/products are implemented (used by superclass):
#define GAIM_PRODUCT_GP
#define GAIM_PRODUCT_IGP
#define GAIM_PRODUCT_GP_EM gpem
#define GAIM_PRODUCT_LCONT
#define GAIM_PRODUCT_LCONT_EM lcem
#define GAIM_PRODUCT_HIP
#define GAIM_PRODUCT_MHIP
#define GAIM_PRODUCT_RCONT
#define GAIM_PRODUCT_OP
#define GAIM_PRODUCT_SCP
#define GAIM_PRODUCT_GPEM
#define GAIM_PRODUCT_LCEM
#define GAIM_PRODUCT_SCPEM
#define GAIM_FUNCTION_GRADEINVOLUTION
#define GAIM_FUNCTION_REVERSE
#define GAIM_FUNCTION_NEGATE
#define GAIM_FUNCTION_ADD
#define GAIM_FUNCTION_SUBSTRACT
#define GAIM_FUNCTION_NORM_A
#define GAIM_FUNCTION_NORMALIZE
#define GAIM_FUNCTION_TAKEGRADE
#define GAIM_FUNCTION_VERSORINVERSE
#define GAIM_FUNCTION_GENERALINVERSE
#define GAIM_FUNCTION_CLIFFORDCONJUGATE
#define GAIM_FUNCTION_HIGHESTGRADE
#define GAIM_FUNCTION_GRADE
#define GAIM_FUNCTION_PROJECT
#define GAIM_FUNCTION_MEETJOIN
#define GAIM_FUNCTION_RANDOM
#define GAIM_FUNCTION_RECIPROCALFRAME
#define GAIM_FUNCTION_FACTOR
#define GAIM_INVERSEPSEUDOSCALAR l3gai::Ii
#define GAIM_PSEUDOSCALAR l3gai::I
#define GAIM_FLOAT double
#define GAIM_DOUBLE
#define GAIM_CLASSNAME l3gai
#define GAIM_OM_CLASSNAME l3gai_om

#define GAIM_CONSTRUCTOR_1_COOR
#define GAIM_CONSTRUCTOR_6_COOR

/* grade macros */
#ifndef GRADE0
#define GRADE0 (1 << 0)
#endif
#ifndef GRADE1
#define GRADE1 (1 << 1)
#endif
#ifndef GRADE2
#define GRADE2 (1 << 2)
#endif
#ifndef GRADE3
#define GRADE3 (1 << 3)
#endif
#ifndef GRADE4
#define GRADE4 (1 << 4)
#endif
#ifndef GRADE5
#define GRADE5 (1 << 5)
#endif
#ifndef GRADE6
#define GRADE6 (1 << 6)
#endif

/* coordinate macros */
#define L3GA_S 0
#define L3GA_I 0
#define L3GA_E01 0
#define L3GA_E23 1
#define L3GA_E02 2
#define L3GA_E31 3
#define L3GA_E03 4
#define L3GA_E12 5
#define L3GA_E01_E23 0
#define L3GA_E01_E02 1
#define L3GA_E23_E02 2
#define L3GA_E01_E31 3
#define L3GA_E23_E31 4
#define L3GA_E02_E31 5
#define L3GA_E01_E03 6
#define L3GA_E23_E03 7
#define L3GA_E02_E03 8
#define L3GA_E31_E03 9
#define L3GA_E01_E12 10
#define L3GA_E23_E12 11
#define L3GA_E02_E12 12
#define L3GA_E31_E12 13
#define L3GA_E03_E12 14
#define L3GA_E01_E23_E02 0
#define L3GA_E01_E23_E31 1
#define L3GA_E01_E02_E31 2
#define L3GA_E23_E02_E31 3
#define L3GA_E01_E23_E03 4
#define L3GA_E01_E02_E03 5
#define L3GA_E23_E02_E03 6
#define L3GA_E01_E31_E03 7
#define L3GA_E23_E31_E03 8
#define L3GA_E02_E31_E03 9
#define L3GA_E01_E23_E12 10
#define L3GA_E01_E02_E12 11
#define L3GA_E23_E02_E12 12
#define L3GA_E01_E31_E12 13
#define L3GA_E23_E31_E12 14
#define L3GA_E02_E31_E12 15
#define L3GA_E01_E03_E12 16
#define L3GA_E23_E03_E12 17
#define L3GA_E02_E03_E12 18
#define L3GA_E31_E03_E12 19
#define L3GA_E01_E23_E02_E31 0
#define L3GA_E01_E23_E02_E03 1
#define L3GA_E01_E23_E31_E03 2
#define L3GA_E01_E02_E31_E03 3
#define L3GA_E23_E02_E31_E03 4
#define L3GA_E01_E23_E02_E12 5
#define L3GA_E01_E23_E31_E12 6
#define L3GA_E01_E02_E31_E12 7
#define L3GA_E23_E02_E31_E12 8
#define L3GA_E01_E23_E03_E12 9
#define L3GA_E01_E02_E03_E12 10
#define L3GA_E23_E02_E03_E12 11
#define L3GA_E01_E31_E03_E12 12
#define L3GA_E23_E31_E03_E12 13
#define L3GA_E02_E31_E03_E12 14
#define L3GA_E01_E23_E02_E31_E03 0
#define L3GA_E01_E23_E02_E31_E12 1
#define L3GA_E01_E23_E02_E03_E12 2
#define L3GA_E01_E23_E31_E03_E12 3
#define L3GA_E01_E02_E31_E03_E12 4
#define L3GA_E23_E02_E31_E03_E12 5

// the layer 0 functions:
// layer 0 functions are always pure C, unless custom float class if used
extern "C" {

extern const int l3gai_omct[192];
extern const int *l3gai_bevt[7];
extern const int l3gai_newBevt[64];
extern const char *l3gai_basisElementNames[64];
extern int l3gai_gradeSize[7];
extern int l3gai_mvSize[128];

/* optimized implementations of products with a result of zero: */
extern void l3gai_opt_zero_result(const double *a, const double *b, double *c);

/* optimized implementations of products: (to be compiled from .opt file) */
extern void l3gai_opt_7F_gp_7F(const double *a, const double *b, double *c);
extern void l3gai_opt_7F_hip_7F(const double *a, const double *b, double *c);
extern void l3gai_opt_7F_mhip_7F(const double *a, const double *b, double *c);
extern void l3gai_opt_7F_lcont_7F(const double *a, const double *b, double *c);
extern void l3gai_opt_7F_rcont_7F(const double *a, const double *b, double *c);
extern void l3gai_opt_7F_op_7F(const double *a, const double *b, double *c);
extern void l3gai_opt_7F_scp_7F(const double *a, const double *b, double *c);
extern void l3gai_general_gp(const double *a[], const double *b[], double *c);
extern void l3gai_general_lcont(const double *a[], const double *b[], double *c);
extern void l3gai_general_hip(const double *a[], const double *b[], double *c);
extern void l3gai_general_mhip(const double *a[], const double *b[], double *c);
extern void l3gai_general_rcont(const double *a[], const double *b[], double *c);
extern void l3gai_general_op(const double *a[], const double *b[], double *c);
extern void l3gai_general_scp(const double *a[], const double *b[], double *c);
extern void l3gai_general_gpem(const double *a[], const double *b[], double *c);
extern void l3gai_general_lcem(const double *a[], const double *b[], double *c);
extern void l3gai_general_scpem(const double *a[], const double *b[], double *c);

/* mapping from grade usage -> index in fp table & the function pointer table */
typedef void (*l3gai_genFuncPtr)(const double *a[], const double *b[], double *c);
typedef void (*l3gai_optFuncPtr)(const double *a, const double *b, double *c);
extern const int l3gai_map_gp_a[];
extern const int l3gai_map_gp_b[];
extern /*const*/ l3gai_optFuncPtr l3gai_func_gp[]; /* pointers to optimized functions for doing 'gp' products */
extern const int l3gai_resultUsage_gp[]; /* grade & memory usage of results of 'gp' products */
extern const int l3gai_map_lcont_a[];
extern const int l3gai_map_lcont_b[];
extern /*const*/ l3gai_optFuncPtr l3gai_func_lcont[]; /* pointers to optimized functions for doing 'lcont' products */
extern const int l3gai_resultUsage_lcont[]; /* grade & memory usage of results of 'lcont' products */
extern const int l3gai_map_hip_a[];
extern const int l3gai_map_hip_b[];
extern /*const*/ l3gai_optFuncPtr l3gai_func_hip[]; /* pointers to optimized functions for doing 'hip' products */
extern const int l3gai_resultUsage_hip[]; /* grade & memory usage of results of 'hip' products */
extern const int l3gai_map_mhip_a[];
extern const int l3gai_map_mhip_b[];
extern /*const*/ l3gai_optFuncPtr l3gai_func_mhip[]; /* pointers to optimized functions for doing 'mhip' products */
extern const int l3gai_resultUsage_mhip[]; /* grade & memory usage of results of 'mhip' products */
extern const int l3gai_map_rcont_a[];
extern const int l3gai_map_rcont_b[];
extern /*const*/ l3gai_optFuncPtr l3gai_func_rcont[]; /* pointers to optimized functions for doing 'rcont' products */
extern const int l3gai_resultUsage_rcont[]; /* grade & memory usage of results of 'rcont' products */
extern const int l3gai_map_op_a[];
extern const int l3gai_map_op_b[];
extern /*const*/ l3gai_optFuncPtr l3gai_func_op[]; /* pointers to optimized functions for doing 'op' products */
extern const int l3gai_resultUsage_op[]; /* grade & memory usage of results of 'op' products */
extern const int l3gai_map_scp_a[];
extern const int l3gai_map_scp_b[];
extern /*const*/ l3gai_optFuncPtr l3gai_func_scp[]; /* pointers to optimized functions for doing 'scp' products */
extern const int l3gai_resultUsage_scp[]; /* grade & memory usage of results of 'scp' products */
extern const int l3gai_map_gpem_a[];
extern const int l3gai_map_gpem_b[];
extern /*const*/ l3gai_optFuncPtr l3gai_func_gpem[]; /* pointers to optimized functions for doing 'gpem' products */
extern const int l3gai_resultUsage_gpem[]; /* grade & memory usage of results of 'gpem' products */
extern const int l3gai_map_lcem_a[];
extern const int l3gai_map_lcem_b[];
extern /*const*/ l3gai_optFuncPtr l3gai_func_lcem[]; /* pointers to optimized functions for doing 'lcem' products */
extern const int l3gai_resultUsage_lcem[]; /* grade & memory usage of results of 'lcem' products */
extern const int l3gai_map_scpem_a[];
extern const int l3gai_map_scpem_b[];
extern /*const*/ l3gai_optFuncPtr l3gai_func_scpem[]; /* pointers to optimized functions for doing 'scpem' products */
extern const int l3gai_resultUsage_scpem[]; /* grade & memory usage of results of 'scpem' products */

extern void l3gai_copy(double *dest, const double *src, int length);
extern void l3gai_null(double *dest, int length);
extern void l3gai_reverse(double *a[7]);
extern void l3gai_cliffordConjugate(double *a[7]);
extern void l3gai_involution(double *a[7]);
extern void l3gai_negate(double *dest, const double *src, int length);
extern void l3gai_addSameGradeUsage(double *c, const double *a, const double *b, int length);
extern void l3gai_add(const double *a[7], const double *b[7], double *c[7]);
extern void l3gai_subSameGradeUsage(double *c, const double *a, const double *b, int length);
extern void l3gai_sub(const double *a[7], const double *b[7], double *c[7]);
extern double l3gai_norm_a(const double a[], int nb);
// end of the layer 0 functions
} /* end of 'extern "C"' */


class l3ga;

class l3gai {
public:
	static l3gai e01;
	static l3gai e23;
	static l3gai e02;
	static l3gai e31;
	static l3gai e03;
	static l3gai e12;
	static l3gai *bv[6];
	static l3gai I;
	static l3gai Ii;

	static const int dim;
	static const int nbCoor;

	l3gai();
	l3gai(const l3gai &a);
	~l3gai();
	l3gai(int gradeUsage, const double *coordinates);
	l3gai(int grade, double c0);
	l3gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5);
	l3gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14);
	l3gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14, double c15, double c16, double c17, double c18, double c19);

	void null();

	void set(int gradeUsage, const double *coordinates);
	void setScalar(const double coordinates[1]);
	void setVector(const double coordinates[6]);
	void set2Vector(const double coordinates[15]);
	void set3Vector(const double coordinates[20]);
	void set4Vector(const double coordinates[15]);
	void set5Vector(const double coordinates[6]);
	void set6Vector(const double coordinates[1]);
	int set(int grade, double c0);
	int set(int grade, double c0, double c1, double c2, double c3, double c4, double c5);
	int set(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14);
	int set(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14, double c15, double c16, double c17, double c18, double c19);
	inline int setScalar(double c0)
		{return set(GRADE0, c0);}
	inline int setVector(double c0, double c1, double c2, double c3, double c4, double c5)
		{return set(GRADE1, c0, c1, c2, c3, c4, c5);}
	inline int set2Vector(double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14)
		{return set(GRADE2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14);}
	inline int set3Vector(double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14, double c15, double c16, double c17, double c18, double c19)
		{return set(GRADE3, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19);}
	inline int set4Vector(double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14)
		{return set(GRADE4, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14);}
	inline int set5Vector(double c0, double c1, double c2, double c3, double c4, double c5)
		{return set(GRADE5, c0, c1, c2, c3, c4, c5);}
	inline int set6Vector(double c0)
		{return set(GRADE6, c0);}

	inline double scalar() const {return((gradeUsage() & GRADE0) ? c[0] : (double)0.0);};

	const char *string(const char *prec = NULL) const;
	void print(const char *text = NULL, const char *prec = NULL) const;
	void fprint(FILE *F, const char *text = NULL, const char *prec = NULL) const;

	static const char *fpPrecision; // floating point precision (during printing)
	static const char *stringStartDelimiter, *stringEndDelimiter; // start and end delimiters of string
	static int setFPPrecision(const char *prec);
	static int setStringDelimiters(char start, char end);

	int usage; /* usage of grades/memory */
	inline int gradeUsage() const {return usage & 0x7f;}
	inline int memUsage() const {return (usage>>0x7) & 0x7f;}


	void gp(const l3gai &a, const l3gai &b);

	void lcont(const l3gai &a, const l3gai &b);

	void hip(const l3gai &a, const l3gai &b);

	void mhip(const l3gai &a, const l3gai &b);

	void rcont(const l3gai &a, const l3gai &b);

	void op(const l3gai &a, const l3gai &b);

	void op(double scalar, const l3gai &a);
	inline void op(const l3gai &a, double scalar) {op(scalar, a);};

	void scp(const l3gai &a, const l3gai &b);

	void gpem(const l3gai &a, const l3gai &b);

	void lcem(const l3gai &a, const l3gai &b);

	void scpem(const l3gai &a, const l3gai &b);
	void copy(const l3gai &a);
	void compress(double epsilon = 1e-14); // compresses (removes all grades which are 0) this multivector in place
	void reverse(const l3gai &a);
	void cliffordConjugate(const l3gai &a);
	void gradeInvolution(const l3gai &a);
	void negate(const l3gai &a);

	void add(const l3gai &a, const l3gai &b);
	void add(double scalar, const l3gai &b);
	inline void add(const l3gai &b, double scalar) {add(scalar, b);};

	void sub(const l3gai &a, const l3gai &b);
	void sub(double scalar, const l3gai &b);
	inline void sub(const l3gai &b, double scalar) {sub(scalar, b);};
	void takeGrade(const l3gai &a, int grade);

	int highestGrade(const l3gai &a, double epsilon = 1e-14);

	int grade() const; // return the grade of 'this', if 'this' is a homogeneous multivector; otherwise it returns -1
	int largestGrade() const; // return the grade with the largest norm_a
	int maxGrade() const; // return the maximum non zero grade of 'this', returns -1 if this = 0
	int versorInverse(const l3gai &a); // compute inverse, for versors only
	int generalInverse(const l3gai &a); // compute inverse, for general multivectors; uses gaussian elimination (slower and less stable than versorInverse)
	void expand(double matrix[], const int table[]) const;
	double norm_a() const;
	double norm_b() const;
	double largestCoordinate() const;
	void normalize(const l3gai &a, int norm);

	int project(const l3gai &blade, const l3gai &a);
	int projectOntoVersor(const l3gai &versor, const l3gai &a);
	int reject(const l3gai &blade, const l3gai &a);

	int versorInverseEM(const l3gai &a);
	int projectEM(const l3gai &blade, const l3gai &a);

	int factor(l3gai factors[], int versor = 0) const;
	inline int factorVersor(l3gai factors[]) const {return factor(factors, 1);};

	int deltaProduct(const l3gai &a, const l3gai &b); // sets this to delta(a, b); returns the grade of the delta product
	int join(const l3gai &a, const l3gai &b, int algorithm = 1); // sets this to join(a, b); returns the grade of the join
	int meet(const l3gai &a, const l3gai &b, int algorithm = 1); // sets this to meet(a, b); returns the grade of the meet
protected:
	int joinAlg1(const l3gai &a, const l3gai &b, int ga, int gb, int gj);
	int joinAlg2(const l3gai &a, const l3gai &b, int ga, int gb, int gj);
public:

	inline int randomBlade(int grade, double scale) {return random(grade, scale, 0);}
	inline int randomVersor(int grade, double scale) {return random(grade, scale, 1);}
	int random(int grade, double scale, int versor);

	static int reciprocalFrame(l3gai f[], const l3gai e[], int nbVectors);

	const double *coordinates(int grade) const;

	double c[64];
protected:
	inline void setUsage(int u) {usage = u;}

	void expand(const double *pa[7]) const;
	void expand2i(const l3gai &b, double const *pa[7], double const *pb[7]) const;
	void expand(const l3gai &b, double const *pa[7], double const *pb[7]) const;
	void compress(double coordinates[64]);

public:
	static int resetProfile();
	static int printProfile(float threshold = 2.0);
	static int saveProfile(const char *filename = NULL);

	inline operator l3ga &() const {return *((l3ga*)this);}
};

#ifdef CLASSNAME
#undef CLASSNAME
#endif
#define CLASSNAME l3ga

#ifdef CLASSNAME_OM
#undef CLASSNAME_OM
#endif
#define CLASSNAME_OM l3ga_om

#include "../gaigenhl.h"
#endif /* _l3gai_H_*/
