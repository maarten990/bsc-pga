
/*
Gaigen 0.99, Copyright (c) 2001-2003, University of Amsterdam

Copying, use and development for education and research purposes 
permitted as long as this license is not removed from the files.

All rights for commercial use reserved; for more information
contact Daniel Fontijne (fontijne@science.uva.nl)

This software is unsupported.
*/

/*
Source file l3ga.cpp, generated by Gaigen 0.99 on Tue Jun 12 23:58:27 2012
*/




#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include "l3ga.h"

int l3gai_expansionTable_gp[] = {
66, 73, 75, 78, 82, 89, 92, 94, 98, 100, 103, 110, 114, 117, 119, 126, 129, 136, 138, 141, 145, 152, 155, 157, 161, 163, 166, 173, 177, 180, 182, 189, 196, 202, 203, 208, 212, 215, 221, 222, 227, 228, 233, 236, 240, 246, 247, 252, 259, 264, 265, 271, 275, 278, 283, 284, 289, 290, 296, 299, 303, 308, 309, 315, 326, 337, 338, 339, 340, 352, 353, 354, 355, 356, 357, 367, 368, 369, 370, 378, 389, 397, 398, 399, 400, 410, 411, 412, 413, 414, 415, 427, 428, 429, 430, 441, 514, 516, 521, 522, 523, 526, 528, 530, 532, 535, 537, 540, 541, 542, 546, 547, 548, 551, 553, 556, 558, 560, 562, 565, 566, 567, 572, 574, 577, 580, 584, 586, 587, 589, 592, 593, 596, 599, 600, 603, 605, 606, 609, 611, 612, 614, 617, 620, 621, 624, 625, 628, 630, 631, 636, 637, 642, 643, 648, 649, 651, 654, 655, 658, 659, 662, 665, 667, 668, 670, 673, 674, 676, 679, 680, 683, 686, 687, 690, 692, 693, 695, 699, 702, 705, 707, 712, 713, 714, 717, 719, 721, 723, 726, 728, 731, 732, 733, 737, 738, 739, 742, 744, 747, 749, 751, 753, 756, 757, 758, 763, 765, 834, 838, 841, 843, 846, 849, 850, 851, 852, 857, 860, 862, 864, 865, 866, 867, 868, 869, 871, 878, 879, 880, 881, 882, 885, 887, 890, 894, 897, 902, 904, 906, 909, 913, 914, 915, 916, 920, 923, 925, 928, 929, 930, 931, 932, 933, 934, 941, 943, 944, 945, 946, 948, 950, 954, 957, 964, 966, 970, 971, 976, 977, 978, 979, 980, 983, 989, 990, 992, 993, 994, 995, 996, 997, 1001, 1004, 1007, 1008, 1009, 1010, 1014, 1015, 1018, 1020, 1027, 1030, 1032, 1033, 1039, 1041, 1042, 1043, 1044, 1046, 1051, 1052, 1056, 1057, 1058, 1059, 1060, 1061, 1064, 1067, 1071, 1072, 1073, 1074, 1076, 1077, 1082, 1083, 1090, 1093, 1097, 1099, 1101, 1102, 1103, 1104, 1106, 1113, 1114, 1115, 1116, 1117, 1118, 1119, 1122, 1124, 1127, 1131, 1132, 1133, 1134, 1138, 1141, 1143, 1145, 1150, 1153, 1157, 1160, 1162, 1165, 1166, 1167, 1168, 1169, 1176, 1178, 1179, 1180, 1181, 1182, 1183, 1185, 1187, 1190, 1195, 1196, 1197, 1198, 1201, 1204, 1206, 1209, 1213, 1220, 1221, 1226, 1227, 1229, 1230, 1231, 1232, 1236, 1239, 1242, 1243, 1244, 1245, 1246, 1247, 1251, 1252, 1257, 1259, 1260, 1261, 1262, 1264, 1270, 1271, 1273, 1276, 1283, 1285, 1288, 1289, 1293, 1294, 1295, 1296, 1299, 1302, 1306, 1307, 1308, 1309, 1310, 1311, 1313, 1314, 1320, 1323, 1324, 1325, 1326, 1327, 1332, 1333, 1337, 1339, 1412, 1418, 1419, 1424, 1428, 1431, 1437, 1438, 1443, 1444, 1449, 1452, 1456, 1462, 1463, 1468, 1475, 1480, 1481, 1487, 1491, 1494, 1499, 1500, 1505, 1506, 1512, 1515, 1519, 1524, 1525, 1531, 1538, 1545, 1547, 1550, 1554, 1561, 1564, 1566, 1570, 1572, 1575, 1582, 1586, 1589, 1591, 1598, 1601, 1608, 1610, 1613, 1617, 1624, 1627, 1629, 1633, 1635, 1638, 1645, 1649, 1652, 1654, 1661, 1670, 1681, 1682, 1683, 1684, 1696, 1697, 1698, 1699, 1700, 1701, 1711, 1712, 1713, 1714, 1722, 1730, 1732, 1734, 1737, 1738, 1739, 1742, 1744, 1745, 1746, 1747, 1748, 1751, 1753, 1756, 1757, 1758, 1760, 1761, 1762, 1763, 1764, 1765, 1767, 1769, 1772, 1774, 1775, 1776, 1777, 1778, 1781, 1782, 1783, 1786, 1788, 1790, 1793, 1796, 1798, 1800, 1802, 1803, 1805, 1808, 1809, 1810, 1811, 1812, 1815, 1816, 1819, 1821, 1822, 1824, 1825, 1826, 1827, 1828, 1829, 1830, 1833, 1836, 1837, 1839, 1840, 1841, 1842, 1844, 1846, 1847, 1850, 1852, 1853, 1858, 1859, 1862, 1864, 1865, 1867, 1870, 1871, 1873, 1874, 1875, 1876, 1878, 1881, 1883, 1884, 1886, 1888, 1889, 1890, 1891, 1892, 1893, 1895, 1896, 1899, 1902, 1903, 1904, 1905, 1906, 1908, 1909, 1911, 1914, 1915, 1918, 1921, 1923, 1926, 1928, 1929, 1930, 1933, 1935, 1937, 1938, 1939, 1940, 1942, 1944, 1947, 1948, 1949, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1960, 1963, 1965, 1967, 1968, 1969, 1970, 1972, 1973, 1974, 1978, 1979, 1981, 1990, 2001, 2002, 2003, 2004, 2016, 2017, 2018, 2019, 2020, 2021, 2031, 2032, 2033, 2034, 2042, 2053, 2061, 2062, 2063, 2064, 2074, 2075, 2076, 2077, 2078, 2079, 2091, 2092, 2093, 2094, 2105, 2114, 2116, 2117, 2121, 2122, 2123, 2125, 2126, 2127, 2128, 2130, 2132, 2135, 2137, 2138, 2139, 2140, 2141, 2142, 2143, 2146, 2147, 2148, 2151, 2153, 2155, 2156, 2157, 2158, 2160, 2162, 2165, 2166, 2167, 2169, 2172, 2174, 2177, 2180, 2181, 2184, 2186, 2187, 2189, 2190, 2191, 2192, 2193, 2196, 2199, 2200, 2202, 2203, 2204, 2205, 2206, 2207, 2209, 2211, 2212, 2214, 2217, 2219, 2220, 2221, 2222, 2224, 2225, 2228, 2230, 2231, 2233, 2236, 2237, 2242, 2243, 2245, 2248, 2249, 2251, 2253, 2254, 2255, 2256, 2258, 2259, 2262, 2265, 2266, 2267, 2268, 2269, 2270, 2271, 2273, 2274, 2276, 2279, 2280, 2283, 2284, 2285, 2286, 2287, 2290, 2292, 2293, 2295, 2297, 2299, 2302, 2305, 2307, 2309, 2312, 2313, 2314, 2317, 2318, 2319, 2320, 2321, 2323, 2326, 2328, 2330, 2331, 2332, 2333, 2334, 2335, 2337, 2338, 2339, 2342, 2344, 2347, 2348, 2349, 2350, 2351, 2353, 2356, 2357, 2358, 2361, 2363, 2365, 2373, 2381, 2382, 2383, 2384, 2394, 2395, 2396, 2397, 2398, 2399, 2411, 2412, 2413, 2414, 2425, 2434, 2441, 2443, 2446, 2450, 2457, 2460, 2462, 2466, 2468, 2471, 2478, 2482, 2485, 2487, 2494, 2497, 2504, 2506, 2509, 2513, 2520, 2523, 2525, 2529, 2531, 2534, 2541, 2545, 2548, 2550, 2557, 2564, 2570, 2571, 2576, 2580, 2583, 2589, 2590, 2595, 2596, 2601, 2604, 2608, 2614, 2615, 2620, 2627, 2632, 2633, 2639, 2643, 2646, 2651, 2652, 2657, 2658, 2664, 2667, 2671, 2676, 2677, 2683, 2756, 2758, 2762, 2763, 2768, 2769, 2770, 2771, 2772, 2775, 2781, 2782, 2784, 2785, 2786, 2787, 2788, 2789, 2793, 2796, 2799, 2800, 2801, 2802, 2806, 2807, 2810, 2812, 2819, 2822, 2824, 2825, 2831, 2833, 2834, 2835, 2836, 2838, 2843, 2844, 2848, 2849, 2850, 2851, 2852, 2853, 2856, 2859, 2863, 2864, 2865, 2866, 2868, 2869, 2874, 2875, 2882, 2886, 2889, 2891, 2894, 2897, 2898, 2899, 2900, 2905, 2908, 2910, 2912, 2913, 2914, 2915, 2916, 2917, 2919, 2926, 2927, 2928, 2929, 2930, 2933, 2935, 2938, 2942, 2945, 2950, 2952, 2954, 2957, 2961, 2962, 2963, 2964, 2968, 2971, 2973, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2989, 2991, 2992, 2993, 2994, 2996, 2998, 3002, 3005, 3012, 3013, 3018, 3019, 3021, 3022, 3023, 3024, 3028, 3031, 3034, 3035, 3036, 3037, 3038, 3039, 3043, 3044, 3049, 3051, 3052, 3053, 3054, 3056, 3062, 3063, 3065, 3068, 3075, 3077, 3080, 3081, 3085, 3086, 3087, 3088, 3091, 3094, 3098, 3099, 3100, 3101, 3102, 3103, 3105, 3106, 3112, 3115, 3116, 3117, 3118, 3119, 3124, 3125, 3129, 3131, 3138, 3141, 3145, 3147, 3149, 3150, 3151, 3152, 3154, 3161, 3162, 3163, 3164, 3165, 3166, 3167, 3170, 3172, 3175, 3179, 3180, 3181, 3182, 3186, 3189, 3191, 3193, 3198, 3201, 3205, 3208, 3210, 3213, 3214, 3215, 3216, 3217, 3224, 3226, 3227, 3228, 3229, 3230, 3231, 3233, 3235, 3238, 3243, 3244, 3245, 3246, 3249, 3252, 3254, 3257, 3261, 3330, 3332, 3337, 3338, 3339, 3342, 3344, 3346, 3348, 3351, 3353, 3356, 3357, 3358, 3362, 3363, 3364, 3367, 3369, 3372, 3374, 3376, 3378, 3381, 3382, 3383, 3388, 3390, 3393, 3396, 3400, 3402, 3403, 3405, 3408, 3409, 3412, 3415, 3416, 3419, 3421, 3422, 3425, 3427, 3428, 3430, 3433, 3436, 3437, 3440, 3441, 3444, 3446, 3447, 3452, 3453, 3458, 3459, 3464, 3465, 3467, 3470, 3471, 3474, 3475, 3478, 3481, 3483, 3484, 3486, 3489, 3490, 3492, 3495, 3496, 3499, 3502, 3503, 3506, 3508, 3509, 3511, 3515, 3518, 3521, 3523, 3528, 3529, 3530, 3533, 3535, 3537, 3539, 3542, 3544, 3547, 3548, 3549, 3553, 3554, 3555, 3558, 3560, 3563, 3565, 3567, 3569, 3572, 3573, 3574, 3579, 3581, 3654, 3665, 3666, 3667, 3668, 3680, 3681, 3682, 3683, 3684, 3685, 3695, 3696, 3697, 3698, 3706, 3717, 3725, 3726, 3727, 3728, 3738, 3739, 3740, 3741, 3742, 3743, 3755, 3756, 3757, 3758, 3769, 3780, 3786, 3787, 3792, 3796, 3799, 3805, 3806, 3811, 3812, 3817, 3820, 3824, 3830, 3831, 3836, 3843, 3848, 3849, 3855, 3859, 3862, 3867, 3868, 3873, 3874, 3880, 3883, 3887, 3892, 3893, 3899, 3906, 3913, 3915, 3918, 3922, 3929, 3932, 3934, 3938, 3940, 3943, 3950, 3954, 3957, 3959, 3966, 3969, 3976, 3978, 3981, 3985, 3992, 3995, 3997, 4001, 4003, 4006, 4013, 4017, 4020, 4022, 4029, -1,
0, 65, 130, 195, 260, 325, 390, 455, 520, 585, 650, 715, 780, 845, 910, 975, 1040, 1105, 1170, 1235, 1300, 1365, 1430, 1495, 1560, 1625, 1690, 1755, 1820, 1885, 1950, 2015, 2080, 2145, 2210, 2275, 2340, 2405, 2470, 2535, 2600, 2665, 2730, 2795, 2860, 2925, 2990, 3055, 3120, 3185, 3250, 3315, 3380, 3445, 3510, 3575, 3640, 3705, 3770, 3835, 3900, 3965, 4030, 4095, -1,
2, 64, 4167, 201, 267, 334, 402, 450, 515, 4630, 644, 4759, 793, 837, 4954, 988, 1054, 1094, 5216, 1250, 1316, 1383, 1417, 1483, 1548, 5674, 1678, 1743, 5867, 1872, 5996, 2030, 2066, 2131, 6255, 2260, 6384, 2418, 2453, 6579, 2613, 2679, 2713, 2780, 2846, 2911, 7033, 3042, 3108, 3173, 7290, 3303, 3368, 7483, 3497, 7612, 3646, 3694, 3762, 3829, 3895, 3960, 8063, 4094, -1,
1, 128, 135, 200, 266, 333, 401, 4545, 579, 598, 708, 727, 792, 901, 922, 987, 1053, 1158, 1184, 1249, 1315, 1382, 5512, 5578, 1612, 1642, 5773, 1807, 1835, 1936, 1964, 2029, 6161, 2195, 2223, 2324, 2352, 2417, 2517, 2547, 2612, 2678, 6808, 6875, 6941, 2975, 3001, 7137, 7203, 3237, 3258, 7398, 3432, 3451, 3561, 3580, 3645, 7789, 7857, 7924, 7990, 4024, 4031, 8189, -1,
4, 4170, 4235, 192, 4300, 336, 404, 471, 4609, 536, 4674, 601, 772, 4957, 5022, 965, 5087, 5219, 5284, 1222, 5349, 1385, 1415, 5546, 5642, 5707, 1708, 5837, 1773, 5902, 1838, 2000, 2096, 6225, 2161, 6290, 2226, 2388, 6582, 6647, 2581, 6712, 2711, 2778, 6905, 7005, 7070, 3040, 7162, 7267, 7332, 3324, 7462, 3389, 7527, 3454, 3625, 3692, 3760, 3827, 7935, 8054, 8119, 4092, -1,
3, 4168, 4233, 256, 268, 335, 403, 470, 4737, 4760, 4802, 4825, 4867, 4955, 5020, 1029, 1055, 5217, 5282, 1286, 1317, 1384, 1479, 1514, 1544, 1609, 1707, 5965, 5997, 6030, 6062, 6095, 2095, 6353, 6385, 6418, 6450, 6483, 6580, 6645, 2645, 2680, 6806, 2842, 2873, 2907, 2972, 3104, 3130, 3169, 3234, 3323, 7590, 7613, 7655, 7678, 7720, 7787, 7855, 3891, 3903, 3956, 4021, 8187, -1,
6, 4177, 4242, 4307, 4372, 320, 4437, 480, 545, 610, 675, 740, 805, 4929, 870, 4994, 935, 5059, 1000, 5124, 1065, 1350, 5551, 5616, 5681, 5746, 1671, 5811, 1736, 5876, 1801, 5941, 1866, 6006, 1931, 6071, 1996, 6136, 6545, 6610, 6675, 6740, 2746, 6870, 2811, 6935, 2876, 7000, 2941, 7065, 3006, 3296, 3361, 3426, 3491, 3556, 3621, 3690, 7807, 7919, 7984, 8049, 8114, 4090, -1,
5, 4173, 4238, 4303, 4368, 384, 405, 474, 539, 604, 669, 734, 799, 5185, 5222, 5250, 5287, 5315, 5352, 5380, 5417, 5445, 5547, 5612, 5677, 5742, 2055, 2099, 2120, 2164, 2185, 2229, 2250, 2294, 2315, 2359, 2380, 2424, 2445, 2510, 2575, 2640, 2745, 7126, 7163, 7191, 7228, 7256, 7293, 7321, 7358, 7386, 7451, 7516, 7581, 7646, 7711, 3754, 3775, 3819, 3884, 3949, 4014, 8185, -1,
7, 8257, 12418, 214, 279, 346, 416, 448, 8712, 12873, 8842, 13003, 810, 9037, 13198, 1003, 1068, 9297, 13458, 1263, 1328, 1395, 1411, 1476, 9752, 13913, 1669, 9947, 14108, 10077, 14238, 2041, 2054, 10337, 14498, 10467, 14628, 2426, 10662, 14823, 2619, 2684, 2700, 2767, 2832, 11117, 15278, 3027, 3092, 11377, 15538, 3285, 11572, 15733, 11702, 15863, 3647, 3679, 3749, 3816, 3881, 12157, 16318, 4088, -1,
4107, 68, 4183, 4290, 217, 4446, 4516, 4555, 512, 4615, 4620, 554, 4875, 848, 4972, 5070, 1006, 1108, 5232, 5330, 1266, 5495, 5506, 1433, 1540, 5655, 5790, 1733, 5850, 5855, 1785, 6110, 6180, 2118, 6240, 6245, 2170, 6500, 2473, 6588, 6695, 2622, 6795, 6862, 2798, 2896, 7020, 7122, 3058, 3156, 7280, 7415, 3349, 7475, 7480, 3391, 7735, 7774, 7844, 7911, 3838, 3945, 8060, 8183, -1,
4106, 132, 151, 4289, 216, 4445, 4515, 458, 576, 583, 4684, 4714, 4874, 912, 940, 5069, 1005, 1172, 1200, 5329, 1265, 5494, 1409, 5528, 1604, 1623, 1693, 1797, 1818, 5919, 5945, 6109, 2083, 2182, 2208, 6309, 6330, 6499, 2537, 2556, 6694, 2621, 2698, 2765, 6893, 2960, 2988, 3025, 7153, 3220, 3248, 3318, 3413, 3443, 7544, 7551, 7734, 3677, 3747, 3814, 7933, 4009, 4028, 4086, -1,
4105, 67, 4182, 4354, 4377, 4444, 4514, 4553, 640, 4743, 652, 4778, 777, 847, 4971, 5134, 5166, 1107, 5231, 5394, 5426, 5493, 5570, 5593, 5635, 1558, 5788, 1861, 5978, 1887, 6009, 2012, 6178, 2246, 6368, 2277, 6394, 2402, 2472, 6587, 6759, 6782, 2697, 6926, 6958, 6991, 2923, 7186, 7218, 7251, 3183, 7413, 3477, 7603, 3512, 7615, 3637, 3676, 3746, 7975, 7998, 8040, 3963, 4085, -1,
4104, 131, 150, 4353, 4376, 4443, 4513, 456, 704, 711, 716, 746, 776, 911, 939, 5133, 5165, 1171, 1199, 5393, 5425, 5492, 1473, 1496, 5699, 5718, 1691, 1925, 1946, 1951, 1977, 2011, 2081, 2310, 2336, 2341, 2362, 2401, 2536, 2555, 6758, 6781, 6792, 2829, 2861, 7055, 7083, 3089, 3121, 7315, 7343, 3316, 3541, 3571, 3576, 3583, 3636, 7771, 7841, 3878, 3901, 8104, 8123, 8180, -1,
12, 88, 153, 8387, 12548, 351, 421, 490, 8712, 8777, 12938, 13003, 768, 877, 942, 9167, 13328, 1137, 1202, 9427, 13588, 1400, 9622, 13783, 1537, 1602, 1721, 9947, 10012, 14173, 14238, 1989, 2106, 10337, 10402, 14563, 14628, 2374, 2493, 2558, 10792, 14953, 2695, 10987, 15148, 2893, 2958, 11247, 15408, 3153, 3218, 3327, 11572, 11637, 15798, 15863, 3605, 3674, 3744, 12027, 16188, 3942, 4007, 4083, -1,
4114, 70, 4192, 226, 292, 4418, 359, 4562, 4627, 559, 4756, 688, 4914, 832, 4935, 4949, 883, 969, 5109, 1035, 5175, 5458, 1442, 1508, 1573, 5690, 5762, 1703, 5827, 1750, 1768, 5883, 5956, 1879, 1897, 6012, 6105, 2046, 2438, 6560, 2594, 2660, 6834, 2761, 6901, 2827, 6967, 2892, 7018, 7032, 2943, 7378, 7443, 3375, 7572, 3504, 7730, 7769, 3710, 3810, 3876, 3941, 8058, 8178, -1,
4113, 134, 160, 225, 291, 4417, 358, 465, 4691, 4719, 4820, 4848, 4913, 896, 903, 5013, 5043, 968, 5108, 1034, 5174, 5457, 5537, 5603, 1637, 1658, 1665, 5798, 5891, 5910, 1832, 1851, 6020, 6039, 1961, 1980, 6104, 2045, 2502, 2528, 2593, 2659, 2737, 6856, 2804, 6922, 2870, 2956, 2986, 7096, 7103, 3281, 7507, 7535, 7636, 7664, 7729, 3672, 7805, 7905, 7971, 4005, 4026, 4081, -1,
4116, 4195, 4260, 198, 4325, 4420, 361, 4592, 529, 4657, 594, 4722, 4884, 4938, 886, 5003, 951, 960, 5068, 5077, 1016, 5460, 1440, 5562, 5667, 5732, 5783, 1724, 1729, 5848, 5862, 1789, 1794, 5913, 5927, 1854, 6084, 2025, 6563, 6628, 2566, 6693, 6832, 2759, 6890, 6899, 2815, 6986, 2934, 7051, 2999, 7408, 3345, 7473, 3410, 7538, 7700, 7767, 3708, 3808, 7930, 8035, 8100, 8176, -1,
4115, 4193, 4258, 262, 293, 4419, 360, 4591, 657, 689, 722, 754, 787, 4936, 884, 5001, 949, 1024, 1036, 5141, 5176, 5459, 1504, 1530, 1569, 1634, 5782, 1723, 1857, 1880, 5990, 6013, 1922, 1945, 6055, 6078, 1987, 6120, 6561, 6626, 2630, 2661, 2735, 2823, 2858, 6963, 6975, 2888, 7028, 2953, 7093, 7407, 3473, 3505, 3538, 3570, 3603, 3670, 7803, 3872, 3898, 3937, 4002, 4079, -1,
4110, 69, 4186, 220, 286, 4482, 4519, 4558, 4623, 555, 4752, 684, 4910, 1088, 5191, 1109, 5235, 1225, 1269, 1291, 1335, 1358, 1436, 1502, 1567, 5689, 6146, 6183, 6211, 2134, 6248, 2171, 6340, 2263, 6377, 2300, 6489, 6526, 6533, 2458, 6684, 6750, 6830, 3017, 3061, 3083, 3127, 3148, 7274, 3192, 7295, 3278, 3343, 7467, 3472, 7596, 3630, 7833, 7870, 7900, 7966, 8031, 3961, 4078, -1,
4109, 133, 154, 219, 285, 4481, 4518, 461, 4687, 4715, 4816, 4844, 4909, 1152, 1159, 1173, 1203, 1224, 1268, 1290, 1334, 1357, 5531, 5597, 1631, 1657, 2049, 2086, 6275, 6294, 6312, 6331, 6404, 6423, 6441, 6460, 6488, 6525, 6597, 6618, 6683, 6749, 2733, 7112, 7156, 7178, 7222, 3212, 3242, 3256, 3263, 7373, 3407, 3435, 3536, 3564, 3629, 3736, 3773, 3803, 3869, 8095, 8121, 8173, -1,
4112, 4189, 4254, 197, 4319, 4484, 4521, 4588, 525, 4653, 590, 4718, 4880, 5194, 5238, 5259, 5303, 1216, 5324, 1237, 5368, 1360, 1434, 5561, 5661, 5726, 6167, 6204, 2113, 6232, 2150, 6269, 2178, 6297, 2215, 6334, 6468, 6505, 2461, 2526, 6661, 2591, 6828, 3015, 7146, 3059, 7167, 7242, 7286, 7307, 7351, 3308, 7437, 3373, 7502, 3438, 3600, 7831, 7868, 7898, 3833, 3933, 3998, 4076, -1,
4111, 4187, 4252, 261, 287, 4483, 4520, 4587, 653, 685, 718, 750, 783, 5192, 5236, 5257, 5301, 1280, 1292, 1301, 1336, 1359, 1498, 1529, 1563, 1628, 6166, 6203, 2241, 2264, 2278, 2301, 2306, 2329, 2343, 2366, 2371, 2408, 2459, 2524, 6725, 6751, 2731, 3079, 3114, 3123, 3135, 3144, 3188, 3209, 3253, 3307, 7565, 7597, 7630, 7662, 7695, 3734, 3771, 7962, 7993, 8027, 8092, 8171, -1,
21, 102, 167, 232, 297, 8517, 12678, 499, 564, 629, 694, 759, 824, 9037, 9102, 9167, 9232, 13393, 13458, 13523, 13588, 1344, 1467, 1532, 1597, 1662, 9882, 9947, 10012, 10077, 10142, 10207, 14368, 14433, 14498, 14563, 14628, 14693, 2433, 2498, 2563, 2628, 2751, 10987, 11052, 11117, 11182, 15343, 15408, 15473, 15538, 3271, 3336, 3401, 3466, 3531, 3596, 11897, 16058, 3798, 3863, 3928, 3993, 4074, -1,
23, 12362, 8331, 199, 4330, 364, 432, 452, 12801, 8728, 8770, 12889, 791, 13149, 9118, 986, 5113, 13411, 9380, 1248, 5370, 1404, 1408, 5516, 13834, 9803, 1680, 14029, 9965, 9998, 14126, 2028, 2068, 14417, 10353, 10386, 14514, 2416, 14774, 10743, 2611, 6719, 2692, 2757, 6879, 15197, 11166, 3014, 7141, 15459, 11428, 3305, 15654, 11581, 11623, 15742, 3644, 3664, 3732, 3797, 7928, 16246, 12215, 4073, -1,
22, 12360, 8329, 263, 298, 363, 431, 451, 12929, 12952, 8898, 8921, 4886, 13147, 9116, 1050, 1081, 13409, 9378, 1312, 1338, 1403, 1472, 1484, 9736, 13897, 1679, 14157, 14189, 10126, 10158, 6123, 2067, 14545, 14577, 10514, 10546, 6511, 14772, 10741, 2675, 2687, 6787, 2821, 2847, 11099, 15260, 3078, 3109, 11361, 15522, 3304, 15782, 15805, 11751, 11774, 7739, 7759, 7827, 3861, 3896, 12148, 16309, 8168, -1,
25, 76, 4202, 8393, 12555, 366, 434, 473, 8707, 12822, 12932, 8855, 770, 863, 4985, 9180, 13342, 1125, 5242, 9442, 13604, 1406, 9609, 13771, 1536, 5639, 1710, 9935, 14059, 14160, 10092, 1998, 2098, 10323, 14447, 14548, 10480, 2386, 2488, 6591, 10805, 14967, 2690, 10972, 15134, 2885, 7002, 11234, 15396, 3142, 7264, 3326, 11560, 15675, 15785, 11708, 3623, 3662, 3730, 12021, 16183, 3925, 8051, 4071, -1,
24, 140, 170, 8392, 12554, 365, 433, 4568, 8771, 8790, 12996, 13015, 769, 927, 953, 9179, 13341, 1189, 1210, 9441, 13603, 1405, 13704, 9674, 1600, 1607, 5805, 9999, 10027, 14224, 14252, 1997, 6193, 10387, 10415, 14612, 14640, 2385, 2552, 2559, 10804, 14966, 6785, 15067, 11037, 2949, 2970, 15329, 11299, 3206, 3232, 7421, 11624, 11643, 15849, 15868, 3622, 7757, 7825, 16116, 12086, 3989, 4019, 8166, -1,
32, 12369, 8338, 4335, 4400, 327, 4467, 454, 8737, 12898, 8867, 13028, 826, 13121, 9062, 9090, 13223, 5078, 1019, 5143, 1084, 1376, 5523, 5588, 13873, 9842, 1664, 5781, 9928, 14068, 14089, 10037, 10058, 14198, 14219, 10167, 2026, 6143, 14737, 10706, 6703, 6768, 2725, 6851, 2792, 6916, 2857, 15192, 11133, 11161, 15294, 3270, 11553, 15714, 11683, 15844, 3642, 3660, 7800, 7891, 7956, 16241, 12210, 4069, -1,
4132, 4180, 112, 210, 4338, 4427, 375, 4580, 518, 4640, 4645, 570, 4900, 4932, 855, 873, 4988, 962, 5081, 5095, 1022, 5476, 1426, 5554, 5652, 1584, 5771, 1719, 1728, 5831, 5836, 5845, 1770, 1779, 1784, 5887, 6091, 2039, 6548, 2480, 2578, 6706, 6820, 2754, 6873, 6887, 2814, 6980, 2903, 2921, 7036, 7396, 3334, 7456, 7461, 3386, 7716, 7755, 3703, 3794, 7922, 8020, 3952, 8164, -1,
4131, 4244, 4272, 209, 4337, 4426, 374, 483, 582, 608, 4709, 4730, 4899, 4996, 5015, 937, 956, 961, 5080, 5094, 1021, 5475, 5521, 1457, 5716, 5744, 1674, 5814, 1792, 1799, 5900, 5909, 5930, 5939, 1848, 1855, 6090, 2038, 6612, 6640, 2577, 6705, 2723, 6849, 2776, 2790, 6909, 7044, 7063, 2985, 3004, 3299, 3398, 3424, 7525, 7546, 7715, 3658, 7798, 7889, 3825, 8084, 8112, 4067, -1,
4130, 4179, 111, 274, 306, 4425, 373, 4578, 646, 4768, 677, 4794, 802, 4931, 854, 872, 4987, 1026, 1049, 5159, 5182, 5474, 1490, 1522, 1555, 5679, 5769, 1717, 1856, 5959, 1868, 5973, 5994, 1907, 6008, 1919, 1993, 6133, 6547, 2479, 2642, 2674, 2722, 2818, 2841, 6951, 6974, 2883, 6998, 7016, 2939, 7394, 3462, 7584, 3493, 7610, 3618, 3657, 7797, 3858, 3890, 3923, 8047, 4066, -1,
4129, 4243, 4271, 273, 305, 4424, 372, 481, 710, 736, 741, 762, 801, 4995, 5014, 936, 955, 1025, 1048, 5158, 5181, 5473, 5585, 5617, 1619, 1647, 1672, 5812, 1920, 1927, 1932, 6037, 1962, 6067, 6072, 6079, 1992, 6132, 6611, 6639, 2641, 2673, 6817, 6913, 6936, 2854, 2877, 2947, 2966, 7080, 7099, 3297, 3526, 3552, 3557, 3578, 3617, 7752, 3700, 7953, 7985, 3987, 4015, 8161, -1,
37, 4209, 4274, 12499, 8468, 332, 4472, 506, 8737, 8802, 12963, 13028, 774, 4952, 893, 5017, 958, 13251, 9192, 9220, 13353, 1381, 13743, 9712, 5649, 5714, 1706, 5823, 9928, 14068, 9993, 14133, 14154, 10102, 14219, 10167, 1984, 6101, 6577, 6642, 14867, 10836, 2720, 15062, 11003, 11031, 15164, 6977, 2918, 7042, 2983, 3322, 11553, 11618, 15779, 15844, 3590, 3655, 7795, 16111, 12080, 8017, 8082, 4064, -1,
26, 12365, 8334, 4331, 4396, 391, 435, 453, 8731, 12892, 8861, 13022, 825, 13377, 13414, 9346, 9383, 5334, 5371, 5399, 5436, 5466, 5519, 5584, 13869, 9838, 2048, 2069, 10312, 10356, 14473, 14517, 10442, 10486, 14603, 14647, 2410, 2431, 10637, 14798, 2603, 2668, 2719, 7107, 7144, 7172, 7209, 15448, 15485, 11417, 11454, 7365, 15643, 11612, 15773, 11742, 7737, 3724, 3768, 3791, 3856, 12141, 16302, 8159, -1,
4126, 4176, 108, 206, 4334, 4491, 4535, 4574, 517, 4634, 4639, 569, 4894, 5188, 1111, 5225, 1148, 1218, 5337, 1255, 5374, 1374, 1422, 5550, 5648, 1580, 6155, 6199, 2112, 6215, 6220, 2133, 2154, 6259, 6264, 2175, 6475, 6519, 2448, 6572, 6670, 2606, 6814, 3010, 7129, 3047, 7166, 7236, 3159, 7273, 3196, 3294, 7429, 3354, 3359, 7481, 3614, 7819, 7863, 7886, 3822, 3920, 8044, 4062, -1,
4125, 4240, 4268, 205, 4333, 4490, 4534, 477, 581, 602, 4703, 4729, 4893, 5252, 5271, 5289, 5308, 1217, 5336, 1254, 5373, 1373, 5517, 1453, 5712, 5740, 2058, 2102, 2176, 2183, 6284, 2197, 6314, 2227, 6328, 6335, 6474, 6518, 2512, 2540, 6669, 2605, 2717, 7105, 3032, 7142, 3069, 7300, 7319, 7337, 7356, 7389, 7493, 7514, 3423, 3449, 3613, 3722, 3766, 3789, 7917, 3984, 4012, 8157, -1,
4124, 4175, 107, 270, 302, 4489, 4533, 4572, 645, 4762, 671, 4793, 796, 5187, 1110, 5224, 1147, 1282, 1305, 1319, 1342, 1372, 1486, 1518, 1551, 5675, 6153, 6197, 2240, 6343, 2252, 2261, 6378, 6387, 2296, 6399, 2377, 2421, 2447, 6571, 6734, 6766, 2716, 3074, 3097, 3111, 3134, 3139, 7254, 3176, 7291, 3292, 7557, 3482, 7583, 3513, 7708, 3721, 3765, 7950, 7982, 8015, 3947, 8156, -1,
4123, 4239, 4267, 269, 301, 4488, 4532, 475, 709, 730, 735, 761, 795, 5251, 5270, 5288, 5307, 1281, 1304, 1318, 1341, 1371, 5581, 5613, 1615, 1643, 2056, 2100, 2304, 2311, 2316, 2325, 2346, 2355, 2360, 2367, 2376, 2420, 2511, 2539, 6733, 6765, 6811, 7169, 7192, 7206, 7229, 3203, 3222, 3240, 3259, 7387, 7621, 7642, 7647, 7673, 7707, 7816, 7860, 3853, 3885, 8079, 8107, 4059, -1,
31, 4205, 4270, 12495, 8464, 396, 440, 505, 8731, 8796, 12957, 13022, 773, 5208, 5245, 5273, 5310, 13507, 13544, 9476, 9513, 5471, 13739, 9708, 5645, 5710, 2090, 2111, 10312, 10356, 10377, 10421, 14538, 14582, 14603, 14647, 2368, 2389, 2477, 2542, 10767, 14928, 2714, 15318, 15355, 11287, 11324, 7233, 7270, 7298, 7335, 7417, 15643, 15708, 11677, 11742, 7685, 3719, 3763, 12011, 16172, 3917, 3982, 8154, -1,
39, 85, 4211, 245, 311, 8526, 12690, 487, 552, 4667, 681, 4796, 830, 9029, 13146, 9180, 9246, 13382, 9312, 13538, 13604, 1346, 1461, 1527, 1592, 5695, 9870, 9935, 14059, 10064, 14188, 10222, 14354, 14419, 10351, 14548, 10480, 14706, 2432, 6535, 2569, 2635, 2750, 10972, 11038, 11103, 15225, 15330, 15396, 15461, 11386, 3266, 3331, 7446, 3460, 7575, 3609, 11886, 16050, 3785, 3851, 3916, 8042, 4057, -1,
38, 149, 179, 244, 310, 8525, 12689, 4582, 616, 635, 745, 764, 829, 9093, 9114, 9179, 9245, 13446, 13472, 13537, 13603, 1345, 5556, 5622, 1656, 1663, 13965, 9999, 10027, 10128, 10156, 10221, 10257, 14483, 14511, 14612, 14640, 14705, 2496, 2503, 2568, 2634, 6845, 15067, 15133, 11167, 11193, 11233, 11299, 15525, 15546, 7361, 3395, 3414, 3524, 3543, 3608, 15981, 11953, 7880, 7946, 3980, 4010, 8152, -1,
41, 4214, 4279, 213, 4344, 8528, 12692, 508, 4646, 573, 4711, 638, 809, 13149, 13214, 9157, 13279, 9315, 9380, 13510, 9445, 1348, 1459, 5567, 5686, 5751, 9900, 14029, 9965, 14094, 10030, 10192, 14384, 10321, 14449, 10386, 14514, 14676, 6538, 6603, 2560, 6668, 2748, 10970, 15097, 15197, 15262, 15328, 11258, 11363, 11428, 3287, 7425, 3352, 7490, 3417, 3588, 11884, 16048, 3783, 7914, 8010, 8075, 4055, -1,
40, 4212, 4277, 277, 312, 8527, 12691, 507, 4774, 4797, 4839, 4862, 4904, 13147, 13212, 9221, 9247, 9313, 9378, 13574, 13605, 1347, 1523, 1535, 1588, 1653, 9899, 14157, 14189, 14222, 14254, 14287, 14383, 10449, 10481, 10514, 10546, 10579, 6536, 6601, 2624, 2636, 6843, 11034, 11065, 11099, 11164, 15392, 15418, 15457, 15522, 3286, 7553, 7576, 7618, 7641, 7683, 15979, 11951, 3847, 3882, 3912, 3977, 8150, -1,
42, 8280, 12441, 8406, 12567, 377, 442, 460, 8712, 12873, 12938, 8907, 775, 9069, 13230, 9195, 13356, 9329, 13490, 9455, 13616, 1407, 9603, 13764, 9729, 13890, 1695, 9947, 14108, 14173, 10142, 2010, 2085, 10337, 14498, 14563, 10532, 2400, 10685, 14846, 10811, 14972, 2688, 10959, 15120, 11085, 15246, 11219, 15380, 11345, 15506, 3320, 11572, 15733, 15798, 11767, 3635, 3653, 3718, 12008, 16169, 12134, 16295, 4053, -1,
4144, 12387, 8356, 224, 4346, 4439, 380, 4564, 8721, 12849, 12882, 8818, 4912, 13130, 9078, 9099, 13239, 967, 5098, 5107, 1023, 5488, 1414, 5541, 13859, 9828, 5764, 1705, 9921, 14040, 14054, 9981, 14082, 10009, 10023, 14142, 6103, 2044, 14755, 10724, 2592, 6714, 6804, 2752, 6860, 6869, 2808, 15178, 11126, 11147, 15287, 7380, 11537, 15665, 15698, 11634, 7728, 7748, 3689, 3782, 7909, 16227, 12196, 8148, -1,
4143, 12385, 8354, 288, 314, 4438, 379, 4563, 8849, 8881, 13010, 13042, 815, 13128, 9076, 9097, 13237, 1031, 1066, 5171, 5183, 5487, 1478, 1509, 9761, 13922, 5763, 1704, 10049, 10072, 14182, 14205, 14210, 14233, 10151, 10174, 2006, 6139, 14753, 10722, 2656, 2682, 2707, 2816, 2828, 6933, 6968, 11080, 15220, 15241, 11189, 7379, 11665, 11697, 15826, 15858, 3631, 3651, 7784, 3846, 3877, 12129, 16290, 4051, -1,
4146, 101, 4218, 8418, 12580, 4441, 382, 4594, 12819, 8751, 8852, 12976, 4882, 844, 4970, 4984, 895, 9161, 13301, 13323, 9271, 5490, 9634, 13796, 1542, 5664, 5785, 1726, 14019, 9942, 9960, 14075, 10052, 14167, 14185, 10108, 6082, 2023, 2469, 6586, 10786, 14948, 6802, 10953, 15093, 15115, 11063, 2880, 6983, 6997, 2931, 7410, 15635, 11567, 11668, 15792, 7698, 7746, 3687, 12002, 16164, 3910, 8032, 8146, -1,
4145, 165, 186, 8417, 12579, 4440, 381, 497, 12883, 12911, 8916, 8944, 4881, 908, 938, 5048, 5055, 9160, 13300, 13322, 9270, 5489, 13729, 9699, 1606, 1632, 1688, 5821, 14083, 14102, 10024, 10043, 10116, 10135, 14249, 14268, 6081, 2022, 2533, 2554, 10785, 14947, 2705, 15048, 10996, 11018, 15158, 2944, 2951, 7061, 7091, 3313, 15699, 15727, 11732, 11760, 7697, 3649, 7782, 16097, 12067, 3974, 4000, 4049, -1,
4140, 12381, 8350, 218, 4345, 4503, 4540, 4560, 8717, 12845, 12878, 8814, 4908, 13386, 13430, 9355, 9399, 1223, 5354, 1267, 5375, 1388, 1413, 5535, 13853, 9822, 6148, 6185, 10305, 14424, 10342, 14461, 14466, 10393, 14503, 10430, 6487, 6524, 10653, 14814, 6682, 2617, 6800, 3008, 7116, 3029, 7160, 15434, 15478, 11403, 11447, 3280, 15629, 11565, 11598, 15726, 3628, 7812, 7849, 7877, 3807, 12125, 16286, 4048, -1,
4139, 12379, 8348, 282, 313, 4502, 4539, 4559, 8845, 8877, 13006, 13038, 811, 13384, 13428, 9353, 9397, 1287, 1322, 1331, 1343, 1387, 1477, 1503, 9755, 13916, 6147, 6184, 10433, 10456, 10470, 10493, 14594, 14617, 14631, 14654, 2390, 2427, 10651, 14812, 6746, 6777, 2703, 3072, 3084, 3093, 3128, 11336, 11380, 15497, 15541, 3279, 15757, 15789, 11726, 11758, 7723, 3715, 3752, 7941, 7967, 16219, 12188, 8143, -1,
4142, 95, 4217, 8412, 12574, 4505, 4542, 4590, 12815, 8747, 8848, 12972, 4878, 1100, 5226, 1144, 5247, 9417, 9461, 13579, 13623, 1390, 9628, 13790, 1541, 5658, 6169, 6206, 14403, 10326, 14440, 10363, 10436, 14551, 10473, 14588, 6466, 6503, 6559, 2489, 14876, 10846, 6798, 11209, 11253, 15371, 15415, 3136, 7239, 3157, 7283, 3310, 11535, 15659, 15760, 11692, 3598, 7810, 7847, 16092, 12062, 8005, 3930, 4046, -1,
4141, 159, 185, 8411, 12573, 4504, 4541, 493, 12879, 12907, 8912, 8940, 4877, 1164, 1194, 1208, 1215, 9416, 9460, 13578, 13622, 1389, 13723, 9693, 1605, 1626, 2072, 2109, 14467, 14486, 14504, 14523, 10500, 10519, 10537, 10556, 6465, 6502, 6623, 6649, 14875, 10845, 2701, 15304, 15348, 11274, 11318, 3200, 3207, 3221, 3251, 7405, 11599, 11627, 15824, 15852, 3597, 3713, 3750, 11995, 16157, 8069, 8090, 8141, -1,
51, 8294, 12455, 251, 316, 8538, 12704, 469, 8756, 12917, 8886, 13047, 831, 9037, 13198, 9195, 9260, 13393, 9362, 13551, 13616, 1351, 1448, 1513, 9789, 13950, 9861, 9947, 14108, 10077, 14238, 10233, 14342, 14433, 10402, 14563, 10532, 14714, 10625, 14786, 2582, 2647, 2744, 10959, 11024, 11117, 15278, 15315, 15380, 15473, 11442, 3264, 11528, 15689, 11658, 15819, 3626, 11871, 16037, 3779, 3844, 12120, 16281, 4044, -1,
4151, 105, 4220, 4327, 254, 12638, 8612, 4599, 533, 4659, 4664, 575, 4919, 9040, 13164, 13262, 9198, 13396, 9328, 9426, 13554, 5451, 5543, 1470, 1577, 5692, 13982, 9925, 14042, 14047, 9977, 14302, 10276, 14406, 10336, 10341, 14458, 10596, 2436, 6551, 6658, 2585, 6839, 15054, 10990, 11088, 15212, 11218, 15346, 15444, 11376, 7371, 3328, 7431, 7436, 3370, 7691, 15966, 11940, 7874, 3801, 3908, 8023, 8139, -1,
4150, 169, 188, 4326, 253, 12637, 8611, 502, 597, 627, 4728, 4735, 4918, 9104, 9132, 13261, 9197, 13460, 13488, 9425, 13553, 5450, 1446, 5565, 1641, 1660, 9885, 9989, 10010, 14111, 14137, 14301, 14371, 14470, 14496, 10405, 10426, 10595, 2500, 2519, 6657, 2584, 2742, 10957, 15085, 11152, 11180, 15313, 11249, 15508, 15536, 3274, 3392, 3399, 7500, 7530, 7690, 11869, 16035, 3777, 7896, 3972, 3991, 4042, -1,
4149, 104, 4219, 4391, 4414, 12636, 8610, 4597, 661, 4787, 696, 4799, 821, 9039, 13163, 13326, 13358, 13395, 9327, 9490, 9522, 5449, 5607, 5630, 5672, 1595, 13980, 10053, 14170, 10079, 14201, 10204, 10274, 14534, 10464, 14565, 10490, 14690, 2435, 6550, 6722, 6745, 2741, 15118, 15150, 15183, 11115, 11282, 11314, 11347, 15471, 7369, 3456, 7559, 3468, 7594, 3593, 11868, 16034, 7938, 7961, 8003, 3926, 4041, -1,
4148, 168, 187, 4390, 4413, 12635, 8609, 500, 725, 755, 760, 767, 820, 9103, 9131, 13325, 13357, 13459, 13487, 9489, 9521, 5448, 1510, 1533, 5736, 5755, 9883, 10117, 10138, 10143, 10169, 10203, 14369, 14598, 14624, 14629, 14650, 14689, 2499, 2518, 6721, 6744, 6836, 11021, 11053, 15247, 15275, 15377, 15409, 11411, 11439, 3272, 3520, 3527, 3532, 3562, 3592, 15963, 11937, 3841, 3864, 8067, 8086, 8136, -1,
56, 125, 190, 8424, 12585, 8543, 12709, 511, 8756, 8821, 12982, 13047, 789, 9069, 9134, 9167, 13328, 13425, 13490, 13523, 9492, 1356, 9659, 13820, 1574, 1639, 9913, 9947, 10012, 14173, 14238, 10181, 14394, 14433, 14498, 10467, 10532, 14662, 2456, 2521, 10755, 14916, 2739, 10987, 15148, 11085, 11150, 15343, 11312, 15441, 15506, 3306, 11528, 11593, 15754, 15819, 3584, 11866, 16032, 11990, 16151, 3905, 3970, 4039, -1,
58, 12401, 8370, 12527, 8496, 362, 4479, 485, 8737, 12898, 12963, 8932, 800, 13144, 9085, 9113, 13246, 13270, 9211, 9239, 13372, 1402, 13715, 9684, 13841, 9810, 1676, 5816, 9928, 14068, 14089, 10037, 14154, 10102, 10123, 14263, 1991, 6131, 14769, 10738, 14895, 10864, 2694, 15043, 10984, 11012, 15145, 15169, 11110, 11138, 15271, 3301, 11553, 15714, 15779, 11748, 3616, 3648, 7765, 16083, 12052, 16209, 12178, 4038, -1,
57, 12397, 8366, 12523, 8492, 426, 447, 479, 8731, 12892, 12957, 8926, 794, 13400, 13437, 9369, 9406, 13526, 13563, 9495, 9532, 5497, 13711, 9680, 13837, 9806, 2060, 2104, 10312, 10356, 14473, 14517, 14538, 14582, 10507, 10551, 2375, 2419, 10669, 14830, 10795, 14956, 2693, 15299, 15336, 11268, 11305, 15425, 15462, 11394, 11431, 7391, 15643, 11612, 11677, 15838, 7706, 3712, 3733, 11983, 16144, 12109, 16270, 8133, -1,
60, 12406, 8375, 243, 4351, 8556, 12720, 489, 12838, 8765, 8807, 12926, 828, 13149, 9118, 9178, 13305, 9315, 13476, 13536, 9466, 1367, 1429, 5560, 13878, 9847, 9872, 14029, 9965, 9998, 14126, 10220, 14356, 10321, 14449, 14482, 10418, 14704, 14730, 10699, 2567, 6698, 2729, 10949, 15071, 15197, 11166, 15302, 11237, 11363, 15524, 3268, 15617, 11544, 11586, 15705, 3607, 11856, 16020, 3776, 7884, 16202, 12171, 4036, -1,
59, 12404, 8373, 307, 319, 8555, 12719, 488, 12966, 12989, 8935, 8958, 4923, 13147, 9116, 9242, 9273, 9313, 13474, 13600, 13626, 1366, 1493, 1528, 9780, 13941, 9871, 14157, 14189, 10126, 10158, 14315, 14355, 10449, 10481, 14610, 14642, 10607, 14728, 10697, 2631, 2666, 6824, 11013, 11039, 11099, 15260, 15366, 15397, 15457, 11426, 3267, 15745, 15768, 11714, 11737, 7702, 15951, 11923, 3840, 3852, 12104, 16265, 8131, -1,
62, 120, 4223, 8437, 12599, 8558, 12722, 510, 8744, 12859, 12969, 8892, 807, 9055, 13177, 9180, 13342, 13413, 9338, 13538, 9508, 1369, 9653, 13815, 1557, 5683, 9902, 9935, 14059, 14160, 10092, 10190, 14386, 14419, 10351, 10452, 14576, 14674, 2444, 6570, 10761, 14923, 2727, 10972, 15134, 11077, 15194, 15330, 11300, 15430, 11360, 3289, 11523, 15638, 15748, 11671, 3586, 11854, 16018, 11977, 16139, 3904, 8007, 4034, -1,
61, 184, 191, 8436, 12598, 8557, 12721, 4605, 8808, 8827, 13033, 13052, 806, 9119, 9145, 9179, 13341, 13477, 13498, 13537, 9507, 1368, 13748, 9718, 1621, 1651, 13997, 9999, 10027, 14224, 14252, 10189, 10289, 14483, 14511, 10516, 10544, 14673, 2508, 2538, 10760, 14922, 6822, 15067, 11037, 11141, 11162, 11233, 15395, 15494, 15520, 7384, 11587, 11606, 15812, 15831, 3585, 15949, 11921, 16072, 12042, 3968, 3975, 8129, -1,
63, 8317, 12478, 8443, 12604, 8569, 12730, 504, 8756, 12917, 12982, 8951, 819, 9069, 13230, 9195, 13356, 13425, 9394, 13551, 9520, 1386, 9640, 13801, 9766, 13927, 9887, 9947, 14108, 14173, 10142, 10202, 14373, 14433, 10402, 10467, 14628, 14688, 10648, 14809, 10774, 14935, 2709, 10959, 15120, 11085, 15246, 15315, 11284, 15441, 11410, 3276, 11528, 15689, 15754, 11723, 3591, 11845, 16006, 11971, 16132, 12097, 16258, 4032, -1
};

const char *l3gai_typeNames[4] = {
	"undefined",
	"blade",
	"versor",
	"multivector"
};

const char *l3gai_basisElementNames[64] = {
"1",
"e01",
"e23",
"e02",
"e31",
"e03",
"e12",
"e01^e23",
"e01^e02",
"e23^e02",
"e01^e31",
"e23^e31",
"e02^e31",
"e01^e03",
"e23^e03",
"e02^e03",
"e31^e03",
"e01^e12",
"e23^e12",
"e02^e12",
"e31^e12",
"e03^e12",
"e01^e23^e02",
"e01^e23^e31",
"e01^e02^e31",
"e23^e02^e31",
"e01^e23^e03",
"e01^e02^e03",
"e23^e02^e03",
"e01^e31^e03",
"e23^e31^e03",
"e02^e31^e03",
"e01^e23^e12",
"e01^e02^e12",
"e23^e02^e12",
"e01^e31^e12",
"e23^e31^e12",
"e02^e31^e12",
"e01^e03^e12",
"e23^e03^e12",
"e02^e03^e12",
"e31^e03^e12",
"e01^e23^e02^e31",
"e01^e23^e02^e03",
"e01^e23^e31^e03",
"e01^e02^e31^e03",
"e23^e02^e31^e03",
"e01^e23^e02^e12",
"e01^e23^e31^e12",
"e01^e02^e31^e12",
"e23^e02^e31^e12",
"e01^e23^e03^e12",
"e01^e02^e03^e12",
"e23^e02^e03^e12",
"e01^e31^e03^e12",
"e23^e31^e03^e12",
"e02^e31^e03^e12",
"e01^e23^e02^e31^e03",
"e01^e23^e02^e31^e12",
"e01^e23^e02^e03^e12",
"e01^e23^e31^e03^e12",
"e01^e02^e31^e03^e12",
"e23^e02^e31^e03^e12",
"e01^e23^e02^e31^e03^e12"
};

int l3gai_gradeSize[7] = {1, 6, 15, 20, 15, 6, 1};
int l3gai_mvSize[128] = {0, 1, 6, 7, 15, 16, 21, 22, 20, 21, 26, 27, 35, 36, 41, 42, 15, 16, 21, 22, 30, 31, 36, 37, 35, 36, 41, 42, 50, 51, 56, 57, 6, 7, 12, 13, 21, 22, 27, 28, 26, 27, 32, 33, 41, 42, 47, 48, 21, 22, 27, 28, 36, 37, 42, 43, 41, 42, 47, 48, 56, 57, 62, 63, 1, 2, 7, 8, 16, 17, 22, 23, 21, 22, 27, 28, 36, 37, 42, 43, 16, 17, 22, 23, 31, 32, 37, 38, 36, 37, 42, 43, 51, 52, 57, 58, 7, 8, 13, 14, 22, 23, 28, 29, 27, 28, 33, 34, 42, 43, 48, 49, 22, 23, 28, 29, 37, 38, 43, 44, 42, 43, 48, 49, 57, 58, 63, 64};

const int l3gai_bevt0[1] = {-1};
const int l3gai_bevt1[6] = {0, 1, 2, 3, 4, 5};
const int l3gai_bevt2[15] = {0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4};
const int l3gai_bevt3[20] = {0, 0, 0, 1, 0, 0, 1, 0, 1, 2, 0, 0, 1, 0, 1, 2, 0, 1, 2, 3};
const int l3gai_bevt4[15] = {0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 2};
const int l3gai_bevt5[6] = {0, 0, 0, 0, 0, 1};
const int l3gai_bevt6[1] = {0};
const int *l3gai_bevt[7] = { // bevt = basis element vector table
	l3gai_bevt0,
	l3gai_bevt1,
	l3gai_bevt2,
	l3gai_bevt3,
	l3gai_bevt4,
	l3gai_bevt5,
	l3gai_bevt6
};
const int l3gai_newBevt[64] = { // bevt = basis element vector table
	0, 1, 2, 4, 8, 16, 32, 3, 5, 6, 9, 10, 12, 17, 18, 20, 24, 33, 34, 36, 40, 48, 7, 11, 13, 14, 19, 21, 22, 25, 26, 28, 35, 37, 38, 41, 42, 44, 49, 50, 52, 56, 15, 23, 27, 29, 30, 39, 43, 45, 46, 51, 53, 54, 57, 58, 60, 31, 47, 55, 59, 61, 62, 63
};

const int l3gai_omct[192] = { // omct = Outer Morphism Construction Table
	-1, -1, 0,
	1, -1, 1,
	2, -1, 1,
	3, -1, 1,
	4, -1, 1,
	5, -1, 1,
	6, -1, 1,
	1, 2, 1,
	1, 3, 1,
	2, 3, 1,
	1, 4, 1,
	2, 4, 1,
	3, 4, 1,
	1, 5, 1,
	2, 5, 1,
	3, 5, 1,
	4, 5, 1,
	1, 6, 1,
	2, 6, 1,
	3, 6, 1,
	4, 6, 1,
	5, 6, 1,
	7, 3, 1,
	7, 4, 1,
	8, 4, 1,
	9, 4, 1,
	7, 5, 1,
	8, 5, 1,
	9, 5, 1,
	10, 5, 1,
	11, 5, 1,
	12, 5, 1,
	7, 6, 1,
	8, 6, 1,
	9, 6, 1,
	10, 6, 1,
	11, 6, 1,
	12, 6, 1,
	13, 6, 1,
	14, 6, 1,
	15, 6, 1,
	16, 6, 1,
	22, 4, 1,
	22, 5, 1,
	23, 5, 1,
	24, 5, 1,
	25, 5, 1,
	22, 6, 1,
	23, 6, 1,
	24, 6, 1,
	25, 6, 1,
	26, 6, 1,
	27, 6, 1,
	28, 6, 1,
	29, 6, 1,
	30, 6, 1,
	31, 6, 1,
	42, 5, 1,
	42, 6, 1,
	43, 6, 1,
	44, 6, 1,
	45, 6, 1,
	46, 6, 1,
	57, 6, 1
};

l3gai l3gai::e01(GRADE1, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0);
l3gai l3gai::e23(GRADE1, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
l3gai l3gai::e02(GRADE1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
l3gai l3gai::e31(GRADE1, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0);
l3gai l3gai::e03(GRADE1, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
l3gai l3gai::e12(GRADE1, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
l3gai *l3gai::bv[6] = {&l3gai::e01, &l3gai::e23, &l3gai::e02, &l3gai::e31, &l3gai::e03, &l3gai::e12};
l3gai l3gai::I(GRADE6, 1.0);
l3gai l3gai::Ii(GRADE6, 1.0);

const int l3gai::dim = 6;
const int l3gai::nbCoor = 64;

l3gai::l3gai() {
	usage = 0;
	c = NULL;
}

l3gai::l3gai(const l3gai &a) {
	usage = 0;
	copy(a);
}

l3gai::l3gai(int gradeUsage, const double *coordinates) {
	usage = 0;
	set(gradeUsage, coordinates);
}

l3gai::~l3gai() {
	setUsage(0);
}

l3gai::l3gai(int grade, double c0) {
	usage = 0;
	set(grade, c0);
}

l3gai::l3gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5) {
	usage = 0;
	set(grade, c0, c1, c2, c3, c4, c5);
}

l3gai::l3gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14) {
	usage = 0;
	set(grade, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14);
}

l3gai::l3gai(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14, double c15, double c16, double c17, double c18, double c19) {
	usage = 0;
	set(grade, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16, c17, c18, c19);
}

void l3gai::null() {
	setUsage(0);
}

void l3gai::set(int gradeUsage, const double *coordinates) {
	setUsage((l3gai_mvSize[gradeUsage] << 7) | gradeUsage);
	l3gai_copy(c, coordinates, l3gai_mvSize[gradeUsage]);
}

void l3gai::setScalar(const double coordinates[1]) {
	setUsage(129);
	l3gai_copy(c, coordinates, 1);
}

void l3gai::setVector(const double coordinates[6]) {
	setUsage(770);
	l3gai_copy(c, coordinates, 6);
}

void l3gai::set2Vector(const double coordinates[15]) {
	setUsage(1924);
	l3gai_copy(c, coordinates, 15);
}

void l3gai::set3Vector(const double coordinates[20]) {
	setUsage(2568);
	l3gai_copy(c, coordinates, 20);
}

void l3gai::set4Vector(const double coordinates[15]) {
	setUsage(1936);
	l3gai_copy(c, coordinates, 15);
}

void l3gai::set5Vector(const double coordinates[6]) {
	setUsage(800);
	l3gai_copy(c, coordinates, 6);
}

void l3gai::set6Vector(const double coordinates[1]) {
	setUsage(192);
	l3gai_copy(c, coordinates, 1);
}

int l3gai::set(int grade, double c0) {
	setUsage(grade | (l3gai_mvSize[grade] << 7));
	c[0] = c0;
	return 0;
}

int l3gai::set(int grade, double c0, double c1, double c2, double c3, double c4, double c5) {
	setUsage(grade | (l3gai_mvSize[grade] << 7));
	c[0] = c0;
	c[1] = c1;
	c[2] = c2;
	c[3] = c3;
	c[4] = c4;
	c[5] = c5;
	return 0;
}

int l3gai::set(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14) {
	setUsage(grade | (l3gai_mvSize[grade] << 7));
	c[0] = c0;
	c[1] = c1;
	c[2] = c2;
	c[3] = c3;
	c[4] = c4;
	c[5] = c5;
	c[6] = c6;
	c[7] = c7;
	c[8] = c8;
	c[9] = c9;
	c[10] = c10;
	c[11] = c11;
	c[12] = c12;
	c[13] = c13;
	c[14] = c14;
	return 0;
}

int l3gai::set(int grade, double c0, double c1, double c2, double c3, double c4, double c5, double c6, double c7, double c8, double c9, double c10, double c11, double c12, double c13, double c14, double c15, double c16, double c17, double c18, double c19) {
	setUsage(grade | (l3gai_mvSize[grade] << 7));
	c[0] = c0;
	c[1] = c1;
	c[2] = c2;
	c[3] = c3;
	c[4] = c4;
	c[5] = c5;
	c[6] = c6;
	c[7] = c7;
	c[8] = c8;
	c[9] = c9;
	c[10] = c10;
	c[11] = c11;
	c[12] = c12;
	c[13] = c13;
	c[14] = c14;
	c[15] = c15;
	c[16] = c16;
	c[17] = c17;
	c[18] = c18;
	c[19] = c19;
	return 0;
}

const char *l3gai::fpPrecision = "%2.2f";
const char *l3gai::stringStartDelimiter = "";
const char *l3gai::stringEndDelimiter = "";

int l3gai::setFPPrecision(const char *prec) {
	if (prec == NULL) return -1;
	fpPrecision = prec;
	return 0;
}

int l3gai::setStringDelimiters(char start, char end) {
	if ((start < 0) || (end < 0)) return -1;
	static char startStr[2], endStr[2];

	startStr[0] = start; startStr[1] = 0;
	stringStartDelimiter = startStr;

	endStr[0] = end; endStr[1] = 0;
	stringEndDelimiter = endStr;
	return 0;
}

const char *l3gai::string(const char *prec /*= NULL*/) const {
	// todo: this whole function is not very (mt-)safe
	static char tmpResult[1024]; 
	tmpResult[0] = 0;

	const int maxResult = 16; 
	static char *result[maxResult];
	static int currentResult = 0;

	char *rBuf = tmpResult;
	int i, j, k = 0, ia = 0, gu = gradeUsage(), s = l3gai_mvSize[gu], p = 0, cnt = 0;
	char buf[32];	

	if (prec == NULL) prec = fpPrecision;
	sprintf(buf, "%cs%s%cs%cs", '%', prec, '%', '%');
	rBuf += sprintf(rBuf, "%s", stringStartDelimiter);
	for (i = 0; i <= 6; i++)
		if (gu & (1 << i)) {
			for (j = 0; j < l3gai_gradeSize[i]; j++) {
				if (fabs(c[k]) > 1e-14) {
					cnt++;
					rBuf += sprintf(rBuf, buf, (p) ? " + " : "", float(c[k]), (i) ? "*" : "", (i) ? l3gai_basisElementNames[ia] : "");
					p = 1;
				}
				k++; ia++;
			}
		}
		else ia += l3gai_gradeSize[i];

	if (cnt == 0) rBuf += sprintf(rBuf, "0");
	rBuf += sprintf(rBuf, "%s", stringEndDelimiter);

	k = strlen(tmpResult) + 1;
	rBuf = result[currentResult] = (char*)realloc(result[currentResult], k);
	currentResult = (currentResult + 1) % maxResult;

	if (rBuf == NULL) {
		printf("Memory allocation failure for %d bytes\n", k);
		return tmpResult; // at least return something...
	}
	else {
		memcpy(rBuf, tmpResult, k);
		return rBuf;
	}
}

void l3gai::print(const char *text /*= NULL*/, const char *prec /*= NULL*/) const {
	fprint(stdout, text, prec);
}

void l3gai::fprint(FILE *F, const char *text /*= NULL*/, const char *prec /*= NULL*/) const {
	if (text) fprintf(F, text);
	fprintf(F, "%s\n", string(prec));
}

int l3gai::nbBlocksAvailable[64 + 1];
int l3gai::maxBlocksAvailable[64 + 1];
double **l3gai::blocks[64 + 1];

void l3gai::doubleMaxBlocks(int n) {
	maxBlocksAvailable[n] = (maxBlocksAvailable[n]) ? maxBlocksAvailable[n] * 2 : 2;
	blocks[n] = (double**)realloc(blocks[n], sizeof(double*) * maxBlocksAvailable[n]);  // todo: check mem alloc
}

void l3gai::addBlocks(int n) {
	const int nb = 128; // nb = just a constant
	int i;
	double *newBlocks = (double*)calloc(sizeof(double) * n, nb);	// todo: check mem alloc
	while (maxBlocksAvailable[n] < nbBlocksAvailable[n] + nb) doubleMaxBlocks(n);
	for (i = 0; i < nb; i++)
		blocks[n][nbBlocksAvailable[n]++] = newBlocks + i * n;
}

void l3gai::setUsage(int u) {
	int n1, n2;

	n1 = memUsage();
	n2 = u >> (6 + 1);
	usage = u;
	if (n1 == n2) return;
	if (n1) {	// free old mem
		if (maxBlocksAvailable[n1] == nbBlocksAvailable[n1]) doubleMaxBlocks(n1);
		blocks[n1][nbBlocksAvailable[n1]] = c;
		nbBlocksAvailable[n1]++;
	}
	if (n2) {	// alloc new mem
		if (!nbBlocksAvailable[n2]) addBlocks(n2);
		nbBlocksAvailable[n2]--;
		c = blocks[n2][nbBlocksAvailable[n2]];
	}
}

void l3gai::copy(const l3gai &a) {
	setUsage(a.usage);
	l3gai_copy(c, a.c, l3gai_mvSize[a.gradeUsage()]);
}

void l3gai::compress(double epsilon /* = 1e-14 */ ) {
	double cc[32];
	int i, j, ia = 0, ib = 0, gu = gradeUsage(), gu2 = 0, f, s;
	for (i = 0; i < 6; i++) {
		if (!(gu & (1 << i))) continue;

		s = l3gai_gradeSize[i];
		j = ia + s;
		f = 0;
		for (; ia < j; ia++)
			if ((c[ia] > epsilon) || (c[ia] < -epsilon)) {f = 1; break;}
		ia = j;
		if (f) {
			l3gai_copy(cc + ib, c + ia - s, s);
			ib += s;
			gu2 |= (1 << i);
		}
	}
	if (gu2 != gu) set(gu2, cc);
}

void l3gai::reverse(const l3gai &a) {
	double *pc[7];
	copy(a);
	if (!(a.gradeUsage() & 76)) return;
	expand( (const double**) pc);
	l3gai_reverse(pc);
}

void l3gai::cliffordConjugate(const l3gai &a) {
	double *pc[7];
	copy(a);
	if (!(a.gradeUsage() & 102)) return;
	expand( (const double**) pc);
	l3gai_cliffordConjugate(pc);
}

void l3gai::gradeInvolution(const l3gai &a) {
	double *pc[7];
	copy(a);
	if (!(a.gradeUsage() & 42)) return;
	expand( (const double**) pc);
	l3gai_involution(pc);
}

void l3gai::negate(const l3gai &a) {
	setUsage(a.usage);
	l3gai_negate(c, a.c, l3gai_mvSize[a.gradeUsage()]);
}

void l3gai::add(const l3gai &a, const l3gai &b) {
	double const *pa[7], *pb[7];
	double *pc[7];
	int gu = a.gradeUsage() | b.gradeUsage();
	setUsage(gu | (l3gai_mvSize[gu] << 7));
	if (a.gradeUsage() == b.gradeUsage()) l3gai_addSameGradeUsage(c, a.c, b.c, memUsage());
	else {
		a.expand(b, pa, pb);
		expand( (const double**) pc);
		l3gai_add(pa, pb, pc);
	}
}

void l3gai::add(double scalar, const l3gai &b) {
	double const *pa[7], *pb[7];
	double *pc[7];
	int gu = GRADE0 | b.gradeUsage();
	setUsage(gu | (l3gai_mvSize[gu] << 7));
	if (GRADE0 == b.gradeUsage()) l3gai_addSameGradeUsage(c, &scalar, b.c, memUsage());
	else {
		memset(pa + 1, 0, sizeof(double*) * 6);
		pa[0] = &scalar;
		b.expand(pb);
		expand( (const double**) pc);
		l3gai_add(pa, pb, pc);
	}
}

void l3gai::sub(const l3gai &a, const l3gai &b) {
	double const *pa[7], *pb[7];
	double *pc[7];
	int gu = a.gradeUsage() | b.gradeUsage();
	setUsage(gu | (l3gai_mvSize[gu] << 7));
	if (a.gradeUsage() == b.gradeUsage()) l3gai_subSameGradeUsage(c, a.c, b.c, memUsage());
	else {
		a.expand(b, pa, pb);
		expand( (const double**) pc);
		l3gai_sub(pa, pb, pc);
	}
}

void l3gai::sub(double scalar, const l3gai &b) {
	double const *pa[7], *pb[7];
	double *pc[7];
	int gu = GRADE0 | b.gradeUsage();
	setUsage(gu | (l3gai_mvSize[gu] << 7));
	if (GRADE0 == b.gradeUsage()) l3gai_subSameGradeUsage(c, &scalar, b.c, memUsage());
	else {
		memset(pa + 1, 0, sizeof(double*) * 6);
		pa[0] = &scalar;
		b.expand(pb);
		expand( (const double**) pc);
		l3gai_sub(pa, pb, pc);
	}
}

// take grade introduced 20020710
void l3gai::takeGrade(const l3gai &a, int gu) {
	int i, gua, s;
	double *bc; 
	const double *ac; 

	// determine what the grage usage 'gu' of the result should be:
	if (gu = ((gua = a.gradeUsage()) & gu)) { // only execute if any grade will be present in the result
		// set the grade usage of the result + allocate memory
		setUsage(gu | (l3gai_mvSize[gu] << 7)); 

		bc = c; ac = a.c; // pointers to the coordinates of source (ac) and result (bc)
		for (i = 1; i <= gu; i = i << 1) { // for each grade that is possibly in the result
			if (gua & i) { // determine if grade is present in source
				s = l3gai_mvSize[i]; // get the size of grade
				if (gu & i) { // determine if grade is present in result
					l3gai_copy(bc, ac, s); // copy coordinates
					bc += s; // increment pointer to result
				}
				ac += s; // increment pointer to source
			}
		}
	}
	else setUsage(0);
}

// added an epsilon value on 2002 07 28
int l3gai::highestGrade(const l3gai &a, double epsilon /* = 1e-14 */) {
	int g = 6, gu = a.gradeUsage(), ia = l3gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = l3gai_gradeSize[g];
			ia -= size;
			cptr = a.c + ia;
			for (i = 0; i < size; i++) 
				if (fabs(cptr[i]) > epsilon) {
					set(1 << g, a.c + ia);
					return g;
				}
		}
	} while ((--g)>= 0); // bug fix on 2003 11 16, used to be while ((--g) _>_ 0)
//return -1; // modification on 20020828

	setUsage(0);
	return 0;
}

int l3gai::grade() const {
	int g = 6, gu = gradeUsage(), idx = l3gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = l3gai_gradeSize[g];
			idx -= size;
			cptr = c + idx;
			for (i = 0; i < size; i++) if (cptr[i] != (double)0.0) return (gu ^ (1 << g)) ? -1 : g;
		}
	} while ((--g)>0);
	return 0;
}

int l3gai::maxGrade() const { 
	int g = 6, gu = gradeUsage(), idx = l3gai_mvSize[gu], size, i;
	const double *cptr;
	do {
		if (gu & (1 << g)) {
			size = l3gai_gradeSize[g];
			idx -= size;
			cptr = c + idx;
			for (i = 0; i < size; i++) if (cptr[i] != (double)0.0) return g;
		}
	} while ((--g)>0);
	return -1;
}

int l3gai::largestGrade() const {
	int g = 0, gu = gradeUsage(), size, i;
	double largest = -1.0, tmp;
	int lg = 0;
	const double *cptr = c;
	do {
		if (gu & (1 << g)) {
			size = l3gai_gradeSize[g];
			if ( (tmp = l3gai_norm_a(cptr, size)) > largest) {
				largest = tmp;
				lg = g;
			}
			gu ^= (1 << g);
			
			cptr += size;
		}
	} while (gu && ((++g)<=6));
	return lg;
}




int l3gai::versorInverse(const l3gai &a) {
	l3gai reverse, scalar;
	reverse.reverse(a);
	scalar.scp(a, reverse);
	if ((scalar.c == NULL) || (scalar.c[0] == 0.0f)) {null(); return -1;}
	scalar.c[0] = 1.0f / scalar.c[0];
	op(scalar, reverse);
	return 0;
}

void l3gai::expand(double matrix[], const int table[]) const {
	double val;
	int i, j = 0, t, g = -1, gi = 0, gu = gradeUsage(), ci = 0;
	for (i = -1; i < 64; i++) {
		if (i == -1) val = 0.0f;
		else {
			if (gi == 0) gi = l3gai_gradeSize[++g];
			if (gu & (1 << g)) val = c[ci++];
			else val = 0.0f;
			gi--;
		}
		while ((t = table[j++]) >= 0) {
			if (t & 8192) matrix[t & 4095] += (t & 4096) ? (double)-val : (double)val;
			else matrix[t & 4095] = (t & 4096) ? (double)-val : (double)val;
		}
	}
}

int l3gai::generalInverse(const l3gai &a) {
	static double matrix[4096];
	double *m[64] = {
		matrix + 0,
		matrix + 64,
		matrix + 128,
		matrix + 192,
		matrix + 256,
		matrix + 320,
		matrix + 384,
		matrix + 448,
		matrix + 512,
		matrix + 576,
		matrix + 640,
		matrix + 704,
		matrix + 768,
		matrix + 832,
		matrix + 896,
		matrix + 960,
		matrix + 1024,
		matrix + 1088,
		matrix + 1152,
		matrix + 1216,
		matrix + 1280,
		matrix + 1344,
		matrix + 1408,
		matrix + 1472,
		matrix + 1536,
		matrix + 1600,
		matrix + 1664,
		matrix + 1728,
		matrix + 1792,
		matrix + 1856,
		matrix + 1920,
		matrix + 1984,
		matrix + 2048,
		matrix + 2112,
		matrix + 2176,
		matrix + 2240,
		matrix + 2304,
		matrix + 2368,
		matrix + 2432,
		matrix + 2496,
		matrix + 2560,
		matrix + 2624,
		matrix + 2688,
		matrix + 2752,
		matrix + 2816,
		matrix + 2880,
		matrix + 2944,
		matrix + 3008,
		matrix + 3072,
		matrix + 3136,
		matrix + 3200,
		matrix + 3264,
		matrix + 3328,
		matrix + 3392,
		matrix + 3456,
		matrix + 3520,
		matrix + 3584,
		matrix + 3648,
		matrix + 3712,
		matrix + 3776,
		matrix + 3840,
		matrix + 3904,
		matrix + 3968,
		matrix + 4032

	};
	double maxp, *tmp, mult;
	int pi, i, j, k;
	double inverse[64];
	inverse[0] = 1.0f;

	// modification for custom float (december 9 2002)
	l3gai_null(inverse + 1, 64-1);

	int it = 0;

	a.expand(matrix, l3gai_expansionTable_gp);

	for (i = 0; i < 64; i++) {	// sweep all columns
		pi = i;
		maxp = (double)fabs(m[i][i]);

		for (j = i + 1; j < 64; j++) // find the max pivot
			if ((double)fabs(m[j][i]) > maxp)
				maxp = (double)fabs(m[pi = j][i]);
		if (inverse[pi] != 0.0f) it = 1;
		if (pi != i) { // swap rows
			if (inverse[i] != 0.0f) it = 1;
			tmp = m[pi]; m[pi] = m[i]; m[i] = tmp;
			if (it) maxp = inverse[pi]; inverse[pi] = inverse[i]; inverse[i] = maxp;
		}

		maxp = m[i][i];
		if (maxp == 0.0f) {	// singular matrix
			setUsage(0);
			return -1;
		}

		for (k = 0; k < 64; k++) { // sweep all other rows
			if (k == i) continue;
			mult = -m[k][i] / maxp;
			for (j = i + 1; j < 64; j++) m[k][j] += m[i][j] * mult;
			if (it) inverse[k] += inverse[i] * mult;
		}

		for (j = i+1; j < 64; j++) m[i][j] /= maxp; // divide the pivot row
		if (it) inverse[i] /= maxp;
	}
	set((1 << 7) - 1, inverse);
	return 0;
}

double l3gai::norm_a() const {
	return l3gai_norm_a(c, l3gai_mvSize[gradeUsage()]);
}

double l3gai::norm_b() const {
	l3gai r, s;
	r.reverse(*this);
	s.scp(*this, r);
	return s.scalar();
}

double l3gai::largestCoordinate() const {
	int nc = l3gai_mvSize[gradeUsage()], i;
	double maxC = 0.0, C;
	
	for (i = 0; i < nc; i++) {
		C = fabs(c[i]);
		if (C > maxC) maxC = C;
	}
	
	return maxC;
}

void l3gai::normalize(const l3gai &a, int norm) {
	double tmpC;
	switch(norm) {
	case 1:
		tmpC = 1.0f / (double)sqrt(a.norm_a());
		break;
	case 2:
		tmpC = 1.0f / (double)sqrt(fabs(a.norm_b()));
		break;
	}
	l3gai scalar(GRADE0, tmpC);
	op(a, scalar);
}

int l3gai::project(const l3gai &blade, const l3gai &a) {
	l3gai tmp, bladeInverse;
	bladeInverse.versorInverse(blade);
	tmp.lcont(a, blade);
	lcont(tmp, bladeInverse);
	return 0;
}

int l3gai::projectOntoVersor(const l3gai &versor, const l3gai &a) {
	l3gai tmp, versorInverse;
	versorInverse.versorInverse(versor);
	tmp.lcont(a, versor);
	gp(tmp, versorInverse);
	return 0;
}

int l3gai::reject(const l3gai &blade, const l3gai &a) {
	l3gai tmp, bladeInverse;
	// todo: check if this code is correct
	bladeInverse.versorInverse(blade);
	tmp.op(blade, a);
	lcont(bladeInverse, tmp);
	return 0;
}

int l3gai::versorInverseEM(const l3gai &a) {
	l3gai reverse, scalar;
	reverse.reverse(a);
	scalar.scpem(a, reverse);
	if (scalar.c[0] == 0.0f) return -1;
	scalar.c[0] = 1.0f / scalar.c[0];
	op(scalar, reverse);
	return 0;
}

int l3gai::projectEM(const l3gai &blade, const l3gai &a) {
	l3gai tmp, bladeInverse;
	bladeInverse.versorInverseEM(blade);
	tmp.lcem(a, blade);
	lcem(tmp, bladeInverse);
	return 0;
}

// todo: ensure everything is euclidean...
int l3gai::factor(l3gai factors[], int versor /* = 0 */) const {
	l3gai ca[2], tmp, fi, tmpbv;
	int ga = (versor) ? maxGrade() : grade(), n = 0, i, idx, cca = 0, gu = gradeUsage(), bev;
	double maxC, tmpC, mul, *c2;
	const double *tmpc;
	static double bvc[6] = {1.0, 0.0, 0.0, 0.0, 0.0, 0.0};

	if (ga <= 0) return 0;

	// compute the multiplication factor require to make every factor of the same order of magnitude
	mul = (double)pow(sqrt(norm_a()), 1.0 / ga);

	// setup current 'a'
	ca[0].copy(*this);

	// get the coordinate array for grade 'ga'
	tmpc = coordinates(1 << ga);

	// find out the maximum coordinate
	maxC = (double)fabs(tmpc[idx = 0]);
	for (i = 1; i < l3gai_gradeSize[ga]; i++) 
		if ( (tmpC = (double)fabs(ca[cca].c[i])) > maxC) {maxC = tmpC;idx = i;}

	// find out which basis vectors we have to project onto the blade
	idx += l3gai_mvSize[0xff >> (8 - ga)];
	bev = l3gai_newBevt[idx];

	// setup a basis vector
	tmpbv.setVector(bvc);
	c2 = tmpbv.c;
	idx = 0;

	i = 1;
	for (; ga > 1; ga--) {
		// find the next coordinate
		do { // note: the first coordinate is always skipped; this is note a bug 
			c2[idx++] = 0.0; // direct manipulation of 'bv'; hack
			c2[idx] = 1.0; // direct manipulation of 'bv'; hack
			i <<= 1;
		} while (!(bev & i));

		tmp.projectEM(ca[cca], tmpbv);
		factors[n].op(mul, tmp); // make all factors approximatelly the same size

		// remove the factor from the blade
		fi.versorInverseEM(factors[n++]); 
		if (versor) ca[cca ^ 1].gpem(fi, ca[cca]);
		else ca[cca ^ 1].lcem(fi, ca[cca]);
		cca ^= 1;
	}

	factors[n++].takeGrade(ca[cca], GRADE1);	// the last factor is equal to the remaining vector

	return n;
}


int l3gai::deltaProduct(const l3gai &a, const l3gai &b) {
	l3gai mv1;
	mv1.gpem(a, b);
	return this->highestGrade(mv1);
}

int l3gai::join(const l3gai &a, const l3gai &b, int algorithm /*= 1*/) {
	l3gai d, factors[6];
	int gj, ga = a.grade(), gb = b.grade(), gd;
	l3gai ca, cb;

	// if we are not handed homogeneous multivectors, take the grade parts with the largest norm
	if (ga < 0) {
		ga = a.largestGrade();
		ca.takeGrade(a, 1 << ga);
	}
	else ca.copy(a);

	if (gb < 0) {
		gb = b.largestGrade();
		cb.takeGrade(b, 1 << gb);
	}
	else cb.copy(b);

	// determine the grade of the join
	if (ga == 0) { // then the join is equal to b
		op(ca, cb); return gb;
	}
	else if (gb == 0) { // then the join is equal to a
		op(cb, ca); return ga;
	}
	else { // the join must be computed
		gd = d.deltaProduct(ca, cb);
		gj = (ga + gb + gd) >> 1;
		return (algorithm == 1) 
			? joinAlg1(ca, cb, ga, gb, gj)
			: joinAlg2(ca, cb, ga, gb, gj);
	}
}

int l3gai::meet(const l3gai &a, const l3gai &b, int algorithm /*= 1*/) {
	l3gai d, factors[6], j, jinv;
	int ga = a.grade(), gb = b.grade(), gd;

	l3gai ca, cb;

	// if we are not handed homogeneous multivectors, take the grade parts with the largest norm
	if (ga < 0) {
		ga = a.largestGrade();
		ca.takeGrade(a, 1 << ga);
	}
	else ca.copy(a);

	if (gb < 0) {
		gb = b.largestGrade();
		cb.takeGrade(b, 1 << gb);
	}
	else cb.copy(b);

	// compute delta product, join, ->meet
	gd = d.deltaProduct(ca, cb);
	j.join(ca, cb, algorithm);
	if (jinv.versorInverse(j)) {
		null();
		return 0;
	}
	lcem(d, jinv);
	return (ga + gb - gd) >> 1;
}

// todo: ensure everything is euclidean...
int l3gai::joinAlg2(const l3gai &a, const l3gai &b, int ga, int gb, int gj) {
	l3gai mv1, factors[6];
	int cg, lg, nf; // gj = grade join, gd = grade delta product

	/*
	we pick the highest-dimension blade to start with,
	and factor the other blade
	*/
	l3gai res[7];
	int factorsTried[7];
	double largestNorm = -1.0f, nm;
	if (ga > gb) {
		if ( (nf = b.factor(factors)) != gb) return -1;	// should never happen
		lg = cg = ga;
		res[cg].copy(a);
	}
	else {
		if ( (nf = a.factor(factors)) != ga) return -1;	// should never happen
		lg = cg = gb;
		res[cg].copy(b);
	}

	// modification for bug of type 'join(e1, e1) = 0' (instead of e1) // 2003 10 28
	if (cg == gj) {	// if we have arrived at the grade of the join:
		copy(res[cg]);
		return gj;
	}

	/*
	Wegde as much factors as we need to get the right grade 
	*/
	factorsTried[cg] = 0;
	while (1) {
		// should we lower the current grade, and try the next factor?
		while (factorsTried[cg] >= nf) cg--;
		if (cg < lg) break;

		// wegde a factor to the result
		res[cg + 1].op(res[cg], factors[factorsTried[cg]]);
		factorsTried[cg + 1] = ++(factorsTried[cg]);
		cg++;

		if (cg == gj) {	// if we have arrived at the grade of the join:
			if ( (nm = res[cg].norm_a()) > largestNorm) {
				largestNorm = nm;
				copy(res[cg]);
			}
			cg--;
		}
	}

	return gj;
}

int l3gai::joinAlg1(const l3gai &a, const l3gai &b, int ga, int gb, int gj) {
	l3gai mv1, b1, b2, factors[6];
	int i, rg, gs; // gj = grade join, gd = grade delta product, rg = required grade, gs = grade size

	/* we pick the highest-dimension blade (b1) to start with */
	l3gai be, pbe, tmp; // be = basis element, pbe = projected basis element
	double v1[20];
	double largestNorm = -1.0f, nm;
	if (ga > gb) {
		b1.copy(a);
		rg = gj - ga;
		b2.copy(b);
	}
	else {
		b1.copy(b);
		rg = gj - gb;
		b2.copy(a);
	}

	// project all possible basis elements of grade 'rg' onto blade b2; wegde them with b1
	gs = l3gai_gradeSize[rg];

	// modification for bug of type 'join(e1, e1) = 0' (instead of e1) // 2003 10 28
	if (gs == 0) { // nothing to do, since 'b1' already has the require grade
		copy(b1);
		return gj;
	}
	
	// modification for custom float (december 9 2002)
	l3gai_null(v1, gs);

	be.set(1 << rg, v1);
	for (i = 0; i < gs; i++) {
		be.c[i] = 1.0f;	// hack
		if (i) be.c[i-1] = 0.0f; // hack
		pbe.projectEM(b2, be);
		tmp.op(b1, pbe);
		if ( (nm = tmp.norm_a()) > largestNorm) {
			largestNorm = nm;
			copy(tmp);
		}
	}

	return gj;
}


int l3gai::random(int grade, double scale, int versor) {

	scale *= (double)2.0;

	// compute how many vector we have to multiply/wegd
	int nb = -1;
	while (grade) {
		grade >>= 1;
		nb++;
	}
	if (nb < 0) return -1;
	else if (nb == 0) {
		setScalar(scale * ((double)rand() / (double)32767 - (double)0.5));
	}
	else {
		int i, j, ct = 0;
		l3gai rv, tmp[2];
		double v[6], scalar = (double)1.0;

		tmp[0].setScalar(&scalar);
		for (i = 0; i < nb; i++) {
			// create a random vector
			for (j = 0; j < 6; j++)
				v[j] = scale * ((double)rand() / (double)32767 - (double)0.5);
			rv.setVector(v);

			// multiply/wegde it to the result
			if (versor) tmp[ct ^ 1].gp(tmp[ct], rv);
			else tmp[ct ^ 1].op(tmp[ct], rv);

			ct ^= 1;
		}

		copy(tmp[ct]);
	}

	return 0;
}

int l3gai::reciprocalFrame(l3gai f[], const l3gai e[], int nbVectors) {
	int cb = 0, i, err, ca, j;
	double scalar = 1.0f;
	l3gai B[2], Bi, tmp, einv, A[2];

	if ((nbVectors <= 0) || (nbVectors > 6)) return 0;

	// build the blade which is the pseudoscalar for the frame 
	B[cb].copy(e[0]);
	for (i = 1; i < nbVectors; i++) {
		B[cb^1].op(B[cb], e[i]);
		cb ^= 1;
	}

	// computer the inverse of the frame
	if (err = Bi.versorInverse(B[cb])) return err;

	// compute the reciprocal vectors
	for (i = 0; i < nbVectors; i++) {
		ca = 0;

		// compute te right scalar factor
		scalar = (i & 1) ? -1.0f : 1.0f;
		A[ca].setScalar(&scalar);

		// compute the blade, with omission of vector e[i]
		for (j = 0; j < nbVectors; j++) {
			if (j == i) continue;
			A[ca^1].op(A[ca], e[j]);
			ca ^= 1;
		}

		// compute reciprocal vector f[i]
		f[i].lcont(A[ca], Bi);
	}

	return 0;
}

int l3gai::mvType(int *grade /*= NULL*/, double epsilon /* = 1e-14 */) const {
// this code fails on 'e1 + (e2 ^ e3)' (says it versor, while it isn't)
	// a = *this
	// compute versor inverse of input
	if (grade) *grade = 0;

	l3gai reverse, scalar, ai;
	reverse.reverse(*this);
	scalar.scpem(*this, reverse); 
	if ((scalar.c == NULL) || (scalar.c[0] == 0.0f)) return GA_MULTIVECTOR;
	scalar.c[0] = 1.0f / scalar.c[0];
	ai.op(scalar, reverse);

	// check if ai * a = 1
	l3gai mv1, mv2, mv3;
	mv1.gpem(ai, *this); 
	mv1.compress(epsilon);
	if (mv1.gradeUsage() > GRADE0) return GA_MULTIVECTOR;
	if ((mv1.gradeUsage() == 0) || (mv1.c[0] < 1.0f - epsilon) || (mv1.c[0] > 1.0f + epsilon)) 
		return GA_MULTIVECTOR;

	// check if a * ai = 1
	mv1.gpem(*this, ai); 
	mv1.compress(epsilon);
	if (mv1.gradeUsage() > GRADE0) return GA_MULTIVECTOR;
	if ((mv1.gradeUsage() == 0) || (mv1.c[0] < 1.0f - epsilon) || (mv1.c[0] > 1.0f + epsilon)) 
		return GA_MULTIVECTOR;

	// test if ai * x * a is of the same grade as 'x' for all basis vectors
	int i, j, g;
	for (i = 0; i < 6; i++) { 
		mv1.gpem(ai, *l3gai::bv[i]);  // todo: EUCLIDEAN?
		mv2.gpem(mv1, *this);  
		mv2.compress(epsilon);
		if (mv2.gradeUsage() & (0xffff ^ GRADE1)) return GA_MULTIVECTOR;
	}

	// normalize 'a' (this is to make sure we don't misqualify 'small' (<epsilon) versors as blades
	scalar.setScalar(sqrt(fabs(scalar.c[0])));
	ai.op(scalar, *this);

	// test if a is of a single grade
	ai.compress(epsilon);
	i = ai.gradeUsage(); j = 0;
	g = GRADE0;
	while (i) {
		if (grade && (i & 1)) *grade = g;
		j += i & 1;
		i >>= 1;
		g <<= 1;
	}
	return (j <= 1) ? GA_BLADE : GA_VERSOR;
}

static int memberOf(char c, const char *set) { 
	int i = 0;
	while (set[i]) {
		if (c == set[i]) return 1;
		i++;
	}
	return 0;
}

int l3gai::parseString(const char *str, const l3ga_ben *ben /*= NULL*/) {
	int idx = 0, pmCnt, beCnt = 0;
	const int strLength = 256;
	double scalar;
	int floatStart, floatEnd, bvStart, bvEnd, i;
	l3gai blade, bv, BE, tmp;
	int stage = 0;
	char floatStr[strLength], bvStr[strLength];

	l3ga_ben defaultBen;
	if (ben == NULL) ben = &defaultBen;

	null();

	if (ben->m_startDelimiter) {
		// the first character found must be equal to m_startDelimiter
		while (str[idx] <= 32) { // skip space until something happens
			if (str[idx] == 0) return -1; // nothing read
			idx++;
		}
		if (str[idx] != ben->m_startDelimiter) return -1; // first character is not the m_startDelimiter
		idx++;
	}

	for (;;) {
		blade.setScalar((double)1.0);
		scalar = (double)1;

		while (str[idx] <= 32) { // skip space until something happens
			if (str[idx] == 0) return (ben->m_endDelimiter) ? -1 : idx; // done or error
			idx ++;
		}

		i = idx;
		pmCnt = 0; // plus minus count
		for (;;) { // parse [+|-]+
			if (str[idx] == '+') {scalar *= (double)+1; pmCnt++;}
			else if (str[idx] == '-') {scalar *= (double)-1; pmCnt++;}
			else if (memberOf(str[idx], "0123456789.")) break; // start of the float
			else if ((str[idx] > 0) && (str[idx] <= 32)); // skip space
			else break;
			idx++;
		}
		if (beCnt && (!pmCnt)) return -1;

		if (memberOf(str[idx], "0123456789.")) { // parse float and '*' or '^'
			// parse the float
			floatStart = idx;
			while (memberOf(str[idx],  "0123456789.eE") ||
				(idx && ((str[idx-1] == 'e') || (str[idx-1] == 'E')) && ((str[idx] == '-') || (str[idx] == '+'))))  idx++;
			floatEnd = idx;
			memcpy(floatStr, str + floatStart, floatEnd - floatStart);
			floatStr[floatEnd - floatStart] = 0;
			if (floatEnd - floatStart <= 0) return -1;
			scalar *= (double)atof(floatStr);

			while (str[idx] <= 32) { // skip space until something happens
				if (str[idx] == 0) {
					tmp.copy(*this); add(scalar, tmp);
					return (ben->m_endDelimiter) ? -1 : idx; // done or error
				}
				idx++;
			}

			// check if next char is +,-,* or 'ben->m_endDelimiter'
			if ((str[idx] == '+') || (str[idx] == '-')) {
				tmp.copy(*this); add(scalar, tmp);
				beCnt++;
				continue;
			}
			else if (ben->m_endDelimiter && (str[idx] == ben->m_endDelimiter)) { // end delimiter
				tmp.copy(*this); add(scalar, tmp);
				return idx+1;
			}
			else if ((str[idx] != '*') && (str[idx] != '^')) return -1; // must be either +,-, ^ or *
			else idx++; // skip over '*' or '^'

			while (str[idx] <= 32) { // skip space until something happens
				if (str[idx] == 0) return -1; // error
				idx++;
			}
		}

		for (;;) { // parse a basis element ex ^ ey ^ ez
			bvStart = idx; // find the start and end of the basis vector name
			while ((str[idx] > 32) && (str[idx] != '-') && (str[idx] != '+') && (str[idx] != '^') && (str[idx] != ben->m_endDelimiter)) idx ++;
			bvEnd = idx;

			// copy name, parse it 
			if ((bvEnd - bvStart + 1) >= strLength) return -1; // error (string too long)
			memcpy(bvStr, str + bvStart, bvEnd - bvStart);
			bvStr[bvEnd - bvStart] = 0;
			if (ben->lookupName(bvStr, BE) < 0) return -1; // basis vector name is invalid

			tmp.copy(blade); blade.op(tmp, BE); // wedge the basis element to the blade

			while (str[idx] <= 32) { // skip space until something happens
				if ((str[idx] == 0) || (str[idx] == ben->m_endDelimiter))  break;
				idx++;
			}
			
			// next char must be a wedge, or this is the end of the blade
			if (str[idx] != '^') break;
			idx++;
		}

		tmp.op(scalar, blade);
		blade.copy(*this);
		add(blade, tmp);
		beCnt++;

		if (str[idx] == ben->m_endDelimiter) return idx + 1;

	}
	return idx; // the function never arrives here?
}

void l3gai::om(const l3gai &a, const l3gai_om &om) {
	int ia = 0;
	setUsage(a.usage);

	if (gradeUsage() & 1) {
		l3gai_opt_om_01x01(om.c + 0, a.c + ia, c + ia);
		ia += 1;
	}

	if (gradeUsage() & 2) {
		l3gai_opt_om_06x06(om.c + 1, a.c + ia, c + ia);
		ia += 6;
	}

	if (gradeUsage() & 4) {
		l3gai_opt_om_0Fx0F(om.c + 37, a.c + ia, c + ia);
		ia += 15;
	}

	if (gradeUsage() & 8) {
		l3gai_opt_om_14x14(om.c + 262, a.c + ia, c + ia);
		ia += 20;
	}

	if (gradeUsage() & 16) {
		l3gai_opt_om_0Fx0F(om.c + 662, a.c + ia, c + ia);
		ia += 15;
	}

	if (gradeUsage() & 32) {
		l3gai_opt_om_06x06(om.c + 887, a.c + ia, c + ia);
		ia += 6;
	}

	if (gradeUsage() & 64) {
		l3gai_opt_om_01x01(om.c + 923, a.c + ia, c + ia);
		ia += 1;
	}

}

void l3gai::expand(const double *pa[7]) const {
	int ia = 0;
	int i, j = 1;
	for (i = 0; i < 7; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			ia += l3gai_gradeSize[i];
		}
		else pa[i] = NULL;
		j <<= 1;
	}
}

void l3gai::expand2i(const l3gai &b, double const *pa[7], double const *pb[7]) const {
	int ia = 0;
	int i, j = 1;
	for (i = 0; i < 7; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			pb[i] = b.c + ia;
			ia += l3gai_gradeSize[i];
		}
		else pa[i] = pb[i] = NULL;
		j <<= 1;
	}
}

void l3gai::expand(const l3gai &b, double const *pa[7], double const *pb[7]) const {
	int ia = 0, ib = 0;
	int i, j = 1;
	for (i = 0; i < 7; i++) {
		if (gradeUsage() & j) {
			pa[i] = c + ia;
			ia += l3gai_gradeSize[i];
		}
		else pa[i] = NULL;
		if (b.gradeUsage() & j) {
			pb[i] = b.c + ib;
			ib += l3gai_gradeSize[i];
		}
		else pb[i] = NULL;
		j <<= 1;
	}
}

void l3gai::compress(double coordinates[64]) {
	int i, j, k, l, s, u;
	double cc[64];
	l = k = u = 0;
	for (i = 0; i < 7; i++) {
		s = l3gai_gradeSize[i];
		for (j = 0; j < s; j++)
			if (coordinates[k + j] != 0.0f) {
				u |= (1 << i);
				l3gai_copy(cc + l, coordinates + k, s);
				l += s;
				break;
			}
		k += s;
	}
	setUsage(u | (l << 7));
	l3gai_copy(c, cc, l);
}

const double *l3gai::coordinates(int grade) const {
	int ia = 0;
	int i, j = 1, gu = gradeUsage();
	static const double null[64] = {0}; // temp test for Brian Bouta problem
	for (i = 0; i < 7; i++) {
		if (j == grade) return (gu & j) ? c + ia : null;
		if (gu & j) ia += l3gai_gradeSize[i];
		j <<= 1;
	}
	return null;
}

int l3gai::fastDual(const l3gai &a) {
	setUsage(a.usage);
	int gua = a.gradeUsage(), gud = 0;
	int ia = l3gai_mvSize[gua], id = 0;
	const double *ca = a.c;
	double *cd = c;
	if (gua & GRADE6) {
		gud |= GRADE0;
		ia -= l3gai_gradeSize[6];
		cd[id + 0] = ca[ia + 0];
		id += l3gai_gradeSize[0];
	}
	if (gua & GRADE5) {
		gud |= GRADE1;
		ia -= l3gai_gradeSize[5];
		cd[id + 4] = -ca[ia + 0];
		cd[id + 5] = ca[ia + 1];
		cd[id + 2] = -ca[ia + 2];
		cd[id + 3] = ca[ia + 3];
		cd[id + 0] = -ca[ia + 4];
		cd[id + 1] = ca[ia + 5];
		id += l3gai_gradeSize[1];
	}
	if (gua & GRADE4) {
		gud |= GRADE2;
		ia -= l3gai_gradeSize[4];
		cd[id + 14] = ca[ia + 0];
		cd[id + 8] = ca[ia + 1];
		cd[id + 9] = -ca[ia + 2];
		cd[id + 6] = ca[ia + 3];
		cd[id + 7] = -ca[ia + 4];
		cd[id + 12] = -ca[ia + 5];
		cd[id + 13] = ca[ia + 6];
		cd[id + 10] = -ca[ia + 7];
		cd[id + 11] = ca[ia + 8];
		cd[id + 5] = ca[ia + 9];
		cd[id + 1] = ca[ia + 10];
		cd[id + 2] = -ca[ia + 11];
		cd[id + 3] = -ca[ia + 12];
		cd[id + 4] = ca[ia + 13];
		cd[id + 0] = ca[ia + 14];
		id += l3gai_gradeSize[2];
	}
	if (gua & GRADE3) {
		gud |= GRADE3;
		ia -= l3gai_gradeSize[3];
		cd[id + 18] = -ca[ia + 0];
		cd[id + 19] = ca[ia + 1];
		cd[id + 16] = -ca[ia + 2];
		cd[id + 17] = ca[ia + 3];
		cd[id + 9] = -ca[ia + 4];
		cd[id + 5] = -ca[ia + 5];
		cd[id + 6] = ca[ia + 6];
		cd[id + 7] = ca[ia + 7];
		cd[id + 8] = -ca[ia + 8];
		cd[id + 4] = -ca[ia + 9];
		cd[id + 15] = ca[ia + 10];
		cd[id + 11] = ca[ia + 11];
		cd[id + 12] = -ca[ia + 12];
		cd[id + 13] = -ca[ia + 13];
		cd[id + 14] = ca[ia + 14];
		cd[id + 10] = ca[ia + 15];
		cd[id + 2] = -ca[ia + 16];
		cd[id + 3] = ca[ia + 17];
		cd[id + 0] = -ca[ia + 18];
		cd[id + 1] = ca[ia + 19];
		id += l3gai_gradeSize[3];
	}
	if (gua & GRADE2) {
		gud |= GRADE4;
		ia -= l3gai_gradeSize[2];
		cd[id + 14] = ca[ia + 0];
		cd[id + 10] = ca[ia + 1];
		cd[id + 11] = -ca[ia + 2];
		cd[id + 12] = -ca[ia + 3];
		cd[id + 13] = ca[ia + 4];
		cd[id + 9] = ca[ia + 5];
		cd[id + 3] = ca[ia + 6];
		cd[id + 4] = -ca[ia + 7];
		cd[id + 1] = ca[ia + 8];
		cd[id + 2] = -ca[ia + 9];
		cd[id + 7] = -ca[ia + 10];
		cd[id + 8] = ca[ia + 11];
		cd[id + 5] = -ca[ia + 12];
		cd[id + 6] = ca[ia + 13];
		cd[id + 0] = ca[ia + 14];
		id += l3gai_gradeSize[4];
	}
	if (gua & GRADE1) {
		gud |= GRADE5;
		ia -= l3gai_gradeSize[1];
		cd[id + 4] = -ca[ia + 0];
		cd[id + 5] = ca[ia + 1];
		cd[id + 2] = -ca[ia + 2];
		cd[id + 3] = ca[ia + 3];
		cd[id + 0] = -ca[ia + 4];
		cd[id + 1] = ca[ia + 5];
		id += l3gai_gradeSize[5];
	}
	if (gua & GRADE0) {
		gud |= GRADE6;
		ia -= l3gai_gradeSize[0];
		cd[id + 0] = ca[ia + 0];
		id += l3gai_gradeSize[6];
	}

	usage = gud | (usage ^ gua);
	return 0;
}

void l3gai::gp(const l3gai &a, const l3gai &b) {

	double const *pa[7], *pb[7];
	double cc[64];
	a.expand(b, pa, pb);
	l3gai_general_gp(pa, pb, cc);
	compress(cc);
}

void l3gai::lcont(const l3gai &a, const l3gai &b) {

	double const *pa[7], *pb[7];
	double cc[64];
	a.expand(b, pa, pb);
	l3gai_general_lcont(pa, pb, cc);
	compress(cc);
}

void l3gai::hip(const l3gai &a, const l3gai &b) {

	double const *pa[7], *pb[7];
	double cc[64];
	a.expand(b, pa, pb);
	l3gai_general_hip(pa, pb, cc);
	compress(cc);
}

void l3gai::mhip(const l3gai &a, const l3gai &b) {

	double const *pa[7], *pb[7];
	double cc[64];
	a.expand(b, pa, pb);
	l3gai_general_mhip(pa, pb, cc);
	compress(cc);
}

void l3gai::rcont(const l3gai &a, const l3gai &b) {

	double const *pa[7], *pb[7];
	double cc[64];
	a.expand(b, pa, pb);
	l3gai_general_rcont(pa, pb, cc);
	compress(cc);
}

void l3gai::op(const l3gai &a, const l3gai &b) {

	double const *pa[7], *pb[7];
	double cc[64];
	a.expand(b, pa, pb);
	l3gai_general_op(pa, pb, cc);
	compress(cc);
}

void l3gai::op(double a, const l3gai &b) {

	double const *pa[7], *pb[7];
	double cc[64];
	b.expand(pb);
	memset(pa + 1, 0, sizeof(double*) * 6);
	pa[0] = &a;
	l3gai_general_op(pa, pb, cc);
	compress(cc);
}

void l3gai::scp(const l3gai &a, const l3gai &b) {

	double const *pa[7], *pb[7];
	double cc[64];
	a.expand(b, pa, pb);
	l3gai_general_scp(pa, pb, cc);
	compress(cc);
}

void l3gai::gpem(const l3gai &a, const l3gai &b) {

	double const *pa[7], *pb[7];
	double cc[64];
	a.expand(b, pa, pb);
	l3gai_general_gpem(pa, pb, cc);
	compress(cc);
}

void l3gai::lcem(const l3gai &a, const l3gai &b) {

	double const *pa[7], *pb[7];
	double cc[64];
	a.expand(b, pa, pb);
	l3gai_general_lcem(pa, pb, cc);
	compress(cc);
}

void l3gai::scpem(const l3gai &a, const l3gai &b) {

	double const *pa[7], *pb[7];
	double cc[64];
	a.expand(b, pa, pb);
	l3gai_general_scpem(pa, pb, cc);
	compress(cc);
}
void l3gai_opt_zero_result(const double *a, const double *b, double *c) {};

int l3gai::resetProfile() {
	return 0;
}
int l3gai::printProfile(float threshold /* = 2.0 */) {
	return 0;
}
int l3gai::saveProfile(const char *filename /*  = NULL */) {
	return 0;
}

l3gai_om::l3gai_om() {
	// modification for custom float (december 9 2002)
	l3gai_null(c, 924);
}

l3gai_om::~l3gai_om() {
}

l3gai_om::l3gai_om(const l3gai vectorImages[6]) {
	initOuterMorphism(vectorImages);
}
l3gai_om::l3gai_om(const l3gai *vectorImages[6]) {
	initOuterMorphism(vectorImages);
}

int l3gai_om::initOuterMorphism(const l3gai vectorImages[6]) {
	const l3gai *vi[6];
	int i;
	for (i = 0; i < 6; i++)
		vi[i] = vectorImages + i;
	return initOuterMorphism(vi);
}

int l3gai_om::initOuterMorphism(const l3gai *vectorImages[6]) {
	int beComputed[64], i, j, k, ic, gs, bei;	// be = Basis Element
	l3gai be[64];
	double scalar = 1.0f;
	const double *bec;

	// set all vectors
	for (i = 1; i <= 6; i++) {
		be[i].takeGrade(*(vectorImages[i-1]), GRADE1);
		beComputed[i] = 1;
	}

	// compute all the other basis elements
	memset(beComputed + 6 + 1, 0, sizeof(int) * (64 - 6 - 1));
	for (i = 6 + 1; i < 64; i++)
		computeBE(be, beComputed, i);

	// insert all coordinates into the matrix
	ic = 1;
	bei = 1;
	for (i = 1; i <= 6; i++) {
		gs = l3gai_gradeSize[i];
		for (j = 0; j < gs; j++) {
			bec = be[bei].coordinates(1 << i);
			for (k = 0; k < gs; k++) {
				c[ic + k * gs] = bec[k];
			}
			ic++;
			bei++;
		}
		ic += gs * (gs-1);
	}
	return 0;
}

int l3gai_om::computeBE(l3gai be[64], int beComputed[64], int idx) {
	int i, j, err;
	l3gai tmp;

	if (!beComputed[i = l3gai_omct[idx * 3 + 0]])
		if (err = computeBE(be, beComputed, i)) return err;
	if (!beComputed[j = l3gai_omct[idx * 3 + 1]])
		if (err = computeBE(be, beComputed, j)) return err;

	if (l3gai_omct[idx * 3 + 2] < 0) {
		tmp.negate(be[i]);
		be[idx].op(tmp, be[j]);
	}
	else {
		be[idx].op(be[i], be[j]);
	}

	beComputed[idx] = 1;

	return 0;
}

int l3gai_om::initSpinor2(const l3gai &Sp) {
	int i;
	l3gai Spi, vectorImages[3], tmp, tmp2;
	Spi.versorInverse(Sp);

	for (i = 0; i < 6; i++) {
		tmp.gp(Sp, *(l3gai::bv[i]));
		tmp2.gp(tmp, Spi);
		vectorImages[i].takeGrade(tmp2, GRADE1);
	}
	
	return initOuterMorphism(vectorImages);
}

l3gai_be::l3gai_be(const char *name, const l3gai &mv) {
	initToNothing();

	if (name) m_name = strdup(name);
	m_mv.copy(mv);
}

l3gai_be::~l3gai_be() {
	if (m_name) free(m_name);
	initToNothing();
}

void l3gai_be::initToNothing() {
	m_name = NULL;
	m_mv.null();
}

int l3gai_be::compareName(const char *name)  const {
	if ((name == NULL) || (m_name == NULL)) return 0;
	return (!strcmp(name, m_name));
}

l3ga_ben::l3ga_ben() {
	initToNothing();
	setDefaults();
}

l3ga_ben::l3ga_ben(char startDelimiter, char endDelimiter) {
	initToNothing();
	setDefaults();
	setDelimiters(startDelimiter, endDelimiter);
}

l3ga_ben::~l3ga_ben() {
	removeAll();
	initToNothing();
}

void l3ga_ben::initToNothing() {
	m_ben = NULL;
	m_nbBen = 0;
	m_startDelimiter = m_endDelimiter = 0;
}

int l3ga_ben::removeAll() {
	int i;
	if (m_ben) {
		for (i = 0; i < m_nbBen; i++)
			if (m_ben[i]) delete m_ben[i];
		free(m_ben);
	}
	m_ben = NULL;
	m_nbBen = 0;
	return 0;
}

int l3ga_ben::addName(const char *name, const l3gai &mv) {
	l3gai tmpMv;
	if (lookupName(name, tmpMv) == 0) return -1; // already present in list
	
	if ( (m_ben = (l3gai_be**)realloc(m_ben, sizeof(l3gai_be*) * (m_nbBen + 1))) == NULL) {
		printf("l3ga_ben::addName(): memory allocation failure for '%d' bytes\n", sizeof(l3gai_be*) * (m_nbBen + 1));
		return -1;
	}

	if ( (m_ben[m_nbBen] = new l3gai_be(name, mv)) == NULL) {
		printf("l3ga_ben::addName(): memory allocation failure for '%d' bytes\n", sizeof(l3gai_be));
		return -1;
	}

	m_nbBen++;

	return 0;
}

int l3ga_ben::removeName(const char *name) {
	int i;

	for (i = 0; i < m_nbBen; i++)
		if (m_ben[i]->compareName(name)) {
			delete m_ben[i];
			m_ben[i] = m_ben[m_nbBen - 1];
			m_nbBen--;
			i--;
		}

	return 0;
}

int l3ga_ben::lookupName(const char *name, l3gai &mv) const {
	int i;

	for (i = 0; i < m_nbBen; i++)
		if (m_ben[i]->compareName(name)) {
			mv.copy(m_ben[i]->m_mv);
			return 0;
		}

	return -1;
}

int l3ga_ben::setDelimiters(char startDelimiter, char endDelimiter) {
	if ((startDelimiter < 0) || (endDelimiter < 0)) return -1;
	m_startDelimiter = startDelimiter;
	m_endDelimiter = endDelimiter;
	return 0;
}

int l3ga_ben::setDefaults() {
	int err;
	removeAll();
	m_startDelimiter = m_endDelimiter = 0;
	if (err = addName("e01", l3gai::e01)) return err;
	if (err = addName("e23", l3gai::e23)) return err;
	if (err = addName("e02", l3gai::e02)) return err;
	if (err = addName("e31", l3gai::e31)) return err;
	if (err = addName("e03", l3gai::e03)) return err;
	if (err = addName("e12", l3gai::e12)) return err;
	return 0;
}

//#include "../gaigenhl.cpp"
//Merging /usr/local/include/gaigen/gaigenhl.cpp into generated code:

// DO NOT TRY TO COMPILE THIS FILE DIRECTLY.
// IT IS MEANT TO BE INCLUDED BY GENERATED CODE!

/*
 *
 * Gaigen, Copyright (c) 2001-2004, University of Amsterdam
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *      * Redistributions of source code must retain the above copyright
 *        notice, this list of conditions and the following disclaimer.
 *      * Redistributions in binary form must reproduce the above copyright
 *        notice, this list of conditions and the following disclaimer in
 *        the documentation and/or other materials provided with the
 *        distribution.
 *      * Neither the name of the University of Amsterdam nor the names of its
 *        contributors may be used to endorse or promote products derived
 *        from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#ifdef GAIM_NAMESPACE
namespace CLASSNAME_NS {
#endif // GAIM_NAMESPACE

CLASSNAME::CLASSNAME() {

}
/*
CLASSNAME::CLASSNAME(GAIM_CLASSNAME &a) {
	copy(a);
}
*/
CLASSNAME::~CLASSNAME() {

}

GAIM_RETURN_TYPE CLASSNAME::operator=(const CLASSNAME &a) {
	copy(a);
	return *this;
}

GAIM_RETURN_TYPE CLASSNAME::operator=(GAIM_FLOAT f) {
	set(GRADE0, &f);
	return *this;
}

#ifdef GAIM_FUNCTION_FASTTEMPVAR
GAIM_RETURN_TYPE CLASSNAME::getTemp() {
	// gets a temporary variable (based on Stroustup (heaven help you if you write an expression which requires more than MV_MAX_TEMP temporaries))
	static int idx = 0;
	static CLASSNAME *temp = NULL;
	if (!temp) {
		int i;
		temp = new CLASSNAME[MV_MAX_TEMP];
		for (i = 0; i < MV_MAX_TEMP; i++) {
			temp[i].setUsage(0xf | (0x7 << 4));
			temp[i].setUsage(0);
		}
	}
//	printf("Temp idx = %d\n", idx);
	if (idx == MV_MAX_TEMP) idx = 0;
	return temp[idx++];
}
#endif // GAIM_FUNCTION_FASTTEMPVAR

#ifdef GAIM_FUNCTION_TAKEGRADE
GAIM_RETURN_TYPE CLASSNAME::grade(int g) const {
	GAIM_RETURN_VAR(result);
//	GAIM_RETURN_VAR(result);
	result.takeGrade(*this, g);
	return result;
}
#endif // GAIM_FUNCTION_TAKEGRADE


#ifdef GAIM_FUNCTION_REVERSE
GAIM_RETURN_TYPE CLASSNAME::operator~() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).reverse(*this);
	return result;
}
#endif // GAIM_FUNCTION_REVERSE

#ifdef GAIM_FUNCTION_CLIFFORDCONJUGATE
GAIM_RETURN_TYPE CLASSNAME::operator--() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).cliffordConjugate(*this);
	return result;
}
#endif // GAIM_FUNCTION_CLIFFORDCONJUGATE

#ifdef GAIM_FUNCTION_GRADEINVOLUTION
GAIM_RETURN_TYPE CLASSNAME::operator++() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).gradeInvolution(*this);
	return result;
}
#endif // GAIM_FUNCTION_GRADEINVOLUTION

#ifdef GAIM_PRODUCT_GP
GAIM_RETURN_TYPE CLASSNAME::operator*=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.gp(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator*=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(a, *this);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE gp(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.gp(a, b);
	return result;
}
GAIM_RETURN_TYPE gp(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}

#define USE_NEW_EXP

#ifdef USE_OLD_EXP
GAIM_RETURN_TYPE CLASSNAME::exp(int order /*= 9*/) const {
	int i, div = 1;
	GAIM_RETURN_VAR(result);

	result.setScalar(1.0);
	if (order == 0) return result;

	CLASSNAME tmp(*this);

	for (i = 1; i < order; i++) {
		result += tmp * (GAIM_FLOAT)(1.0 / (GAIM_FLOAT)div);

		if (i < order-1) {
			div *= (i+1);
			tmp *= *this;
		}
	}

	return result;
}
#endif /* USE_OLD_EXP */

#ifdef USE_NEW_EXP
GAIM_RETURN_TYPE CLASSNAME::exp(int order /*= 9*/) const {
	/*
	Improved version of exp thanks to Robert Valkenburg & students
	*/
    int i;
    CLASSNAME result;

    result.setScalar(1.0);
    if (order == 0) {
        GAIM_RETURN_VAR(r);
        r = result;
        return r;
    }

    // scale by power of 2 so that its norm is < 1
    unsigned long max = (unsigned long)largestCoordinate();
    unsigned long scale=1;
    if (max > 1) scale <<= 1;
    while (max)
    {
        max >>= 1;
        scale <<= 1;
    }

    CLASSNAME scaled = (*this) / (GAIM_FLOAT)(scale);

    // taylor approximation
    CLASSNAME tmp;

    tmp.setScalar(1.0);
    for (i = 1; i < order; i++) {
        tmp = tmp*scaled/(GAIM_FLOAT)(i);
        result += tmp;
    }

    // undo scaling
    while (scale > 1)
    {
        result *= result;
        scale >>= 1;
    }
    GAIM_RETURN_VAR(r);
    r = result;
    return r;
}
#endif /* USE_NEW_EXP */


#ifndef GAIM_FUNCTION_FASTDUAL
GAIM_RETURN_TYPE CLASSNAME::dual() const {
	GAIM_RETURN_VAR(result);
	result.gp(*this, Ii);
	return result;
}
#endif // GAIM_FUNCTION_FASTDUAL

#endif // GAIM_PRODUCT_GP

#ifdef GAIM_PRODUCT_GP_EM
GAIM_RETURN_TYPE gpem (const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result. GAIM_PRODUCT_GP_EM (a, b);
	return result;
}
GAIM_RETURN_TYPE gpem (GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
#endif // GAIM_PRODUCT_GP_EM


#ifdef GAIM_FUNCTION_FASTDUAL
GAIM_RETURN_TYPE CLASSNAME::fastDual() const {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).fastDual(*this);
	return result;
}
#endif // GAIM_FUNCTION_FASTDUAL


#ifdef GAIM_FUNCTION_VERSORINVERSE
GAIM_RETURN_TYPE CLASSNAME::versorInverse() const {
	GAIM_RETURN_VAR(result);
	result.versorInverse(*this);
	return result;
}
#endif
#ifdef GAIM_FUNCTION_LOUNESTOINVERSE
GAIM_RETURN_TYPE CLASSNAME::lounestoInverse() const {
	GAIM_RETURN_VAR(result);
	result.lounestoInverse(*this);
	return result;
}
#endif
#ifdef GAIM_FUNCTION_GENERALINVERSE
GAIM_RETURN_TYPE CLASSNAME::generalInverse() const {
	GAIM_RETURN_VAR(result);
	result.generalInverse(*this);
	return result;
}
#endif

#ifdef GAIM_PRODUCT_IGP
GAIM_RETURN_TYPE CLASSNAME::inverse() const {
	GAIM_RETURN_VAR(result);
	result.inverse(*this);
	return result;
}

GAIM_RETURN_TYPE CLASSNAME::operator/=(const CLASSNAME &a) {
	CLASSNAME tmp, tmp2;
	tmp2.inverse(a);
	tmp.gp(*this, tmp2);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator/=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(1.0f / a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_IGP

#ifdef GAIM_PRODUCT_SCP
GAIM_RETURN_TYPE CLASSNAME::operator%=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.scp(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator%=(GAIM_FLOAT a) {
	GAIM_FLOAT f = scalar() * a;
	setScalar(&f);
	return *this;
}
GAIM_RETURN_TYPE scp(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.scp(a, b);
	return result;
}
GAIM_RETURN_TYPE scp(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.set(GRADE0, mulScalar(a, b.scalar()));
	return result;
}
#endif // GAIM_PRODUCT_SCP

#ifdef GAIM_PRODUCT_LCONT
GAIM_RETURN_TYPE lcont(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.lcont(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator<<=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.lcont(*this, a);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_LCONT

#ifdef GAIM_PRODUCT_LCONT_EM
GAIM_RETURN_TYPE lcem(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result. GAIM_PRODUCT_LCONT_EM (a, b);
	return result;
}
#endif // GAIM_PRODUCT_LCONT_EM

#ifdef GAIM_PRODUCT_RCONT
GAIM_RETURN_TYPE rcont(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.rcont(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator>>=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.rcont(*this, a);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_RCONT

#ifdef GAIM_PRODUCT_HIP
GAIM_RETURN_TYPE hip(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.hip(a, b);
	return result;
}
GAIM_RETURN_TYPE hip(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _a(a);
	result.hip(_a, b);
	return result;
}
GAIM_RETURN_TYPE hip(const CLASSNAME &a, GAIM_FLOAT b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _b(b);
	result.hip(a, _b);
	return result;
}
#endif // GAIM_PRODUCT_HIP

#ifdef GAIM_PRODUCT_MHIP
GAIM_RETURN_TYPE mhip(const CLASSNAME &a, const CLASSNAME &b) { // GAIM_RETURN_TYPE used to read CLASSNAME & (modified 10-10-2002)
	GAIM_RETURN_VAR(result);
	result.mhip(a, b);
	return result;
}
GAIM_RETURN_TYPE mhip(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _a(a);
	result.mhip(_a, b);
	return result;
}
GAIM_RETURN_TYPE mhip(const CLASSNAME &a, GAIM_FLOAT b) {
	GAIM_RETURN_VAR(result);
	CLASSNAME _b(b);
	result.mhip(a, _b);
	return result;
}
#endif // GAIM_PRODUCT_MHIP


#ifdef GAIM_PRODUCT_OP
GAIM_RETURN_TYPE op(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
GAIM_RETURN_TYPE op(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.op(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator^=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.op(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator^=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.op(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_PRODUCT_OP

#ifdef GAIM_FUNCTION_MEETJOIN
GAIM_RETURN_TYPE meet(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.meet(a, b);
	return result;
}

GAIM_RETURN_TYPE join(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.join(a, b);
	return result;
}

#endif // GAIM_FUNCTION_MEETJOIN


#ifdef GAIM_FUNCTION_ADD
GAIM_RETURN_TYPE add(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.add(a, b);
	return result;
}
GAIM_RETURN_TYPE add(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.add(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator+=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.add(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator+=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.add(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_FUNCTION_ADD

#ifdef GAIM_FUNCTION_SUBSTRACT
GAIM_RETURN_TYPE sub(const CLASSNAME &a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.sub(a, b);
	return result;
}
GAIM_RETURN_TYPE sub(GAIM_FLOAT a, const CLASSNAME &b) {
	GAIM_RETURN_VAR(result);
	result.sub(a, b);
	return result;
}
GAIM_RETURN_TYPE CLASSNAME::operator-=(const CLASSNAME &a) {
	CLASSNAME tmp;
	tmp.sub(*this, a);
	this->copy(tmp);
	return *this;
}
GAIM_RETURN_TYPE CLASSNAME::operator-=(GAIM_FLOAT a) {
	CLASSNAME tmp;
	tmp.add(a, *this);
	this->copy(tmp);
	return *this;
}
#endif // GAIM_FUNCTION_SUBSTRACT

#ifdef GAIM_FUNCTION_NEGATE
GAIM_RETURN_TYPE negate(const CLASSNAME &a) {
	GAIM_RETURN_VAR(result);
	((GAIM_CLASSNAME&)result).negate(a);
	return result;
}
#endif //GAIM_FUNCTION_NEGATE



#ifdef GAIM_FUNCTION_NORMALIZE
GAIM_RETURN_TYPE CLASSNAME::normal(int norm /* = 1 */) const {
	GAIM_RETURN_VAR(result);
	result.normalize(*this, norm);
	return result;
}
#endif // GAIM_FUNCTION_NORMALIZE


#ifdef GAIM_PRODUCT_OM
CLASSNAME_OM::CLASSNAME_OM(const CLASSNAME *vectorImages[3]) {
	initVectorImages(vectorImages);
}

CLASSNAME_OM::CLASSNAME_OM(const CLASSNAME &spinor) {
	initSpinor(spinor);
}


int CLASSNAME_OM::initSpinor(const CLASSNAME &spinor) {
	CLASSNAME si(spinor.inverse()), v, vi[GA_MAX_DIM];
	GAIM_FLOAT coordinates[GA_MAX_DIM];
	int i;

	memset(coordinates, 0, sizeof(GAIM_FLOAT) * GA_MAX_DIM);

	for (i = 0; i < CLASSNAME::dim; i++) {
		coordinates[i] = 1.0;
		if (i > 0) coordinates[i-1] = 0.0;
		v.setVector(coordinates);
		vi[i] = ((spinor * v) * si)(GRADE1);

	}
	return initVectorImages(vi);
}


GAIM_RETURN_TYPE om(const CLASSNAME_OM &om, const CLASSNAME &a) {
	GAIM_RETURN_VAR(result);

	result.om(a, om);

	return result;
}


#ifdef GAIM_NAMESPACE
}
#endif // GAIM_NAMESPACE


#endif // GAIM_PRODUCT_OM


