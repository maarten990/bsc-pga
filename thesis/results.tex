\section{Implementation}
\label{ch:implementation}
\TODO{Introductory text.}


\subsection{Design decision}

\TODO{Convert from note-wise text to nicer prose.}

Extending an existing program with more functionality can be done in two ways. 1: wrapping the original program in another layer of coding. 2: changing the code of the original program and recompile the whole thing.

\newcommand{\pro}{\textbf{+} &}
\newcommand{\con}{\textbf{--} &}
\newcommand{\que}{\textbf{?} &}
\begin{tabular}{p{0.5cm}p{5.5cm}|p{0.5cm}p{5.5cm}}
  & Wrap program & & Edit source code \\
  \hline
  \con User will insert text in a separate box from the connected GAViewer, OR I need to build a whole new GUI. & \pro Is nicely integrated in current program \\
  \pro Don't need to understand a complex code base & \con Code is not well-documented \\
  \pro Can be done in C, C++, Java (limited by GAIGEN's output). My Java programming skills are better than those in C/C++ & \con Must be done in C++ \\
  \con Java is often (a bit) slower than C++ & \pro C++ is fast in array manipulation \\
  \pro GAIGEN 2.5 must be much faster than GAIGEN 1.0 & \que Need to find out if APIs of different GAIGENs are the same \\
  \pro Can be wrapped over (and over and over\ldots), or use other GAViewer implementation. & \con Is not out-of-the-box compatible with other extensions of GAViewer, but can be made by patches and quite some more work \\
  \con Multiple wrappers make running it difficult/slow & \pro Merging multiple edits of codebase makes implementation difficult, but running easy \\
  \que How to cope with \texttt{dynamic}/dragged and interdepencency? & \pro Dragging and \texttt{dynamic} is implemented \\
  \con Code to implement user interaction will be quite complex & \pro Is provided, doesn't need to be touched \\
  \pro Can run ``modern'' versions of libraries (FLTK 1.3, ANTLR 3.4, GAIGEN 2.5) & \con Is based on old libraries (FLTK 1.1, ANTLR ??? GAIGEN 1.0), implies less functionality/speed \\
  \con Need to write a whole new grammar & \que Need to edit old, undocumented grammar, of \emph{which} edition of ANTLR? \\
  \con No possibility to add new graphical elements; everything must be composed from CGA elements & \que Should be possible, not sure how much effort that will cost (regulus, screws)
\end{tabular}

Decided to edit the source code.  Replaced \iga{} with \lga{}. 

\subsection{Computing with \lga{} in GAViewer}
GAViewer relies on code generated by Gaigen for the implementation of each model~\cite{Gaigen}.  Although more recent versions of Gaigen, such as version 2.5, have a better performance, the code for \lga{} has been generated by the same version of Gaigen, version 1.0, which generated the other models as well.  This has three reasons.  The API of more recent versions are not compatible with the API of the version used by the application.  The documentation of GAViewer states that it is inappropriate to use GAViewer in applications that need good performance, as the internal, interpreted programming language is too slow and limited~\cite[page 7]{GAViewer}.  Therefore, performance improvements in only a model would not suffice to make the program more useful.  Furthermore, the used implementations are fast enough to handle hand-typed expressions without any noticeable delay for the user.

\subsection{Models and casting}
The geometric interpretation of an object of geometric algebra is based on its model.  When an expression is evaluated without any explicit model specifier, GAViewer will try to evaluate it in the model of \ega{} first.  If the expression contains terms of a different model, GAViewer automatically applies the appropriate model.  In case there are terms that cannot be interpreted in any model, those evaluate to \texttt{0}.

GAViewer has support for casting objects from one model to another.  Multivectors are expressed on the source model's basis, and corresponding basis vectors of the target model are multiplied by the source model's factors.  For example, the expression \texttt{3.00*e1\^{}e5 + 0.50*e3\^{}no} evaluates to an object of model \cbga{}.  When cast to \cga{} it evaluates to \texttt{0.50*e3\^{}no}, as \cga{} only knows \texttt{e1}, \texttt{e2}, \texttt{e3}, \texttt{no}, and \texttt{ni}.  Casting to \pga{}, results in \texttt{0.50*e3\^{}e0}, because \texttt{no} and \texttt{e0} have corresponding semantics.  Casting to \ega{} results in \texttt{0}, as both \texttt{e1\^{}e5} and \texttt{e3\^{}no} can be interpreted in the model.

The casting from \lga{} to \pga{} has been implemented in the same way as expressions from the Pl\"ucker model are embedded in the homogeneous model through the embedding function $\Em$, defined in \autoref{eq:Em}.  The casting to other models is equivalent to casting to \pga{}, and then to the target model.

Casting to \lga{} has been done in a corresponding way.  As a consequence, only even grade terms of a multivector can be cast from the current models to \lga{}.  The objects \texttt{e1\^{}e2\^{}e3\^{}e0} from \pga{} and \texttt{e1\^{}e2\^{}e3\^{}no} from \cga{} and \cbga{}, are algebraically equivalent to \texttt{-e01\^{}e23}, \texttt{-e02\^{}e31} and \texttt{-e03\^{}e12}.  This ambiguity has been resolved by returning the sum of all these three blades, divided by \texttt{3}.

\subsection{Blade interpretation and visualization}
\Autoref{ch:research} discusses several classes of blades with their geometric interpretation.  In this section, the computations of the characteristics needed to draw these blades are given, together with a justification of the visualization.

\TODO{Explain what kind of characteristics one expects to encounter.  Examples:}
\begin{itemize}
  \item Weight, as meant in the homogeneous model.
  \item Location with respect to the origin.  GAViewer uses a certain standardized location on the object, so drawing is made easier.
  \item Direction
  \item Normal
  \item Orthogonal1 to normal and ortho2
  \item Orthogonal2 to normal and ortho1
  \item Pitch
  \item Rotation
  \item Signed radius
\end{itemize}


\comment{Treat implementation of grade 4, 5, 6 in section on 2, 1, 0, resp.?}
\comment{Maybe in start of the higher-level section?}
\subsubsection{Grade 0}
GAViewer does not visualize scalars for the originally implemented models, \ega{}, \pga{}, \cga{}, \cbga{}, and \iga.  With \lga{}, we have decided to follow this example.  It adds a piece of consistency in the interface of the application.  When no explicit casting is done, objects are cast to the simplest model that contains the object.  Scalars are thus identified as part of \ega{}.  When they are cast to \lga{}, it is consistent not to display the object, as no geometric semantics of this element have changed.


\subsubsection{Grade 1}
1-blades can be either a real line, an ideal line or a screw axis.  Each class needs to be interpreted slightly different.

Real lines have a weight, direction and a location.  The direction vector $\V{d}$ as mentioned in \autoref{sec:plucker} determines the line's orientation.  To determine its direction properly, the software use the normalized direction $\V{d} / \norm{\V{d}}$.

The location is standardized to be the point closest to the origin of GAViewer's drawing area.  The classical literature on Pl\"ucker coordinates~\cite{Shoemake} presents a way to parameterize the homogeneous points on a line $-\plucker{\V{d}, \V{m}}$.  This parametrization is given by $p(t) = \V{m} \times \V{d} + t \V{d} + \V{d}^2\ez$.  For $t = 0$, the normalized point nearest to the origin is $(\V{m} \times \V{d}) / \V{d}^2$.

Recognizing this repetitious dividing by $\norm{\V{d}}$ and $\V{d}^2$, this seems

For its weight, one cannot take the inner product with itself, as lines are represented by null blades.  Recognizing the repetitious appearance of$\V{d}$ by normalization of the normalized direction and location of the line, it seems reasonable that $\norm{\V{d}}$ will represent the weight.  As current literature has not mentioned weight, the application uses this values.

Real lines are represented similar to the lines of \pga, \cga and \cbga; a solid line with optional direction marks.  The length of the marks are a visual clue of the weight.

Ideal lines cannot be characterized in this way, as $\V{d} = 0$ per definition.  They have no specific location (each point on an ideal line is infinitely far away from any other non-ideal point).  Then that means that $\V{m}$ represents an ideal line's direction, and $\norm{\V{m}}$ is its norm.

The direction of an ideal line $L$ can be seen as a direct or indirect representation.  Directly, this would give us a line through the origin, in the direction of $\dual{\Em(L)}$, where $\V{d}_{\dual{\Em(L)}} = \edual{\Em(L)}$.  With this representation, ideal lines are displayed the same way as real lines, except for that the line is stippled to show the difference. 

In the indirect representation, the ideal line is represented as a circle in $\Em(L)$, where the direction acts as the ideal line's normal.  This agrees with the interpretation of ideal lines as horizons.  The direction is represented by hooks attached on the circle.  Weight can be visualized either by the length of the marks, or by varying the radius of the circle.  To prevent confusion with ``real'' circles of other models and for consistency with the line visualization, the horizon visualization is stippled.

Ideal lines are not represented by the same visualization as \ega's bivectors are, even though they have a more directional aspect than the other vector classes.  This has been done to make clear that these objects represent lines nonetheless, and are fundamentally different from \ega's bivectors, even when an ideal line can be cast to such a bivector.

% Screws!


\subsubsection{Grade 2}
\TODO{Some implemented.  Explain where errors arise.}


\subsubsection{Grade 3}
\comment{None implemented}


\subsubsection{Grade 4}
\comment{Fully implemented as dual to grade 2}


\subsubsection{Grade 5}
\comment{Fully implemented as dual to grade 1}


\subsubsection{Grade 6}
The originally implemented models show a slight inconsistency for visualization of their pseudoscalar.  While GAViewer displays a transparant sphere for \ega{}'s pseudoscalar, the other models display nothing.  Again, we have chosen for consistency.  By duality to scalars, it is safe to say that the semantics of the pseudoscalar have not changed.
