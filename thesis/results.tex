\section{Implementation}
\label{ch:implementation}
\TODO{Introductory text.}


\subsection{Software design decision}
Extending GAViewer's functionalities can be done in two ways.  

Since version 0.4, GAViewer can open a TCP port for communication with other programs~\cite{GAViewer}.  The extended functionality can be implemented by a program that maintains an own interface for user input.  The input will be sent to GAViewer over a TCP port, after it has been processed by the new application.  Textual results are returned over the TCP port, and thus can be shown in the application's own user interface.  However, the visualization of the elements will be shown in GAViewer's own viewport.  The user has to switch between user interfaces to view textual or visual representations, which the user probably experiences as confusing or annoying.  To show the new model's blades correctly, it should be possible to characterize their visualization in terms of elements of other models, and elements of those models should be passed around between the new program and GAViewer.  This limitation seems undesired for our elements; no supported model has primitives that can make up a screw axis' visualization.  

Users might still interact with the drawn elements in GAViewer.  This means that their transformations will have to be translated to corresponding transformations of our model.  All objects, like a pencil of lines, will have to be drawn by a set of elements of an existing model.  This complexity grows when such elements of the new model are declared dynamic; a whole net of interdependencies arises.  We would rather avoid code complexity, as that often gives rise to bugs.

The C++ source code of GAViewer is freely available on the internet\footnote{The source code of GAViewer can be downloaded from \url{http://geometricalgebra.net/gaviewer\_download.html}.}.  This means that GAViewer could also be extended by adding the new functionality in the original source code, and compile it all together to form a unified piece of software.  Because there is very little documentation in the source code on how to extend the functionality of GAViewer with a new model, an old model that has gone out of use might be replaced with our new one.  With a textual search through the source code, it will be possible to find all hooks for adding the right functionality.  

The problems that arose from extension through an external implementation do not apply.  The unified user interface can be taken for granted.  User interaction and dynamic statement management are all implemented independent from the models.  Only the transformation resulting in the new object when dragged has to be implemented once.  This is easy to do for all elements, because our model is operational.  New graphical elements can be made when needed, because calls to OpenGL routines can be made. 

We have decided to remove the model for \iga{} and substitute it with our new model, named \lga{}.  No element of \iga{} currently has visualizations and after a short interview, interest in \iga{} within the user base of GAViewer has dropped.

\subsection{Computing with \lga{} in GAViewer}
GAViewer relies on code generated by Gaigen for the implementation of each model~\cite{Gaigen}.  Although more recent versions of Gaigen, such as version 2.5, have a better performance, the code for \lga{} has been generated by the same version of Gaigen, version 1.0, which generated the other models as well.  This has three reasons.  The API of more recent versions are not compatible with the API of the version used by the application.  The documentation of GAViewer states that it is inappropriate to use GAViewer in applications that need good performance, as the internal, interpreted programming language is too slow and limited~\cite[page 7]{GAViewer}.  Therefore, performance improvements in only a model would not suffice to make the program more useful.  Furthermore, the used implementations are fast enough to handle hand-typed expressions without any noticeable delay for the user.

\subsection{Models and casting}
The geometric interpretation of an object of geometric algebra is based on its model.  When an expression is evaluated without any explicit model specifier, GAViewer will try to evaluate it in the model of \ega{} first.  If the expression contains terms of a different model, GAViewer automatically applies the appropriate model.  In case there are terms that cannot be interpreted in any model, those evaluate to \texttt{0}.

GAViewer has support for casting objects from one model to another.  Multivectors are expressed on the source model's basis, and corresponding basis vectors of the target model are multiplied by the source model's factors.  For example, the expression \texttt{3.00*e1\^{}e5 + 0.50*e3\^{}no} evaluates to an object of model \cbga{}.  When cast to \cga{} it evaluates to \texttt{0.50*e3\^{}no}, as \cga{} only knows \texttt{e1}, \texttt{e2}, \texttt{e3}, \texttt{no}, and \texttt{ni}.  Casting to \pga{}, results in \texttt{0.50*e3\^{}e0}, because \texttt{no} and \texttt{e0} have corresponding semantics.  Casting to \ega{} results in \texttt{0}, as both \texttt{e1\^{}e5} and \texttt{e3\^{}no} can be interpreted in the model.

The casting from \lga{} to \pga{} has been implemented in the same way as expressions from the Pl\"ucker model are embedded in the homogeneous model through the embedding function $\Em$, defined in \autoref{eq:Em}.  The casting to other models is equivalent to casting to \pga{}, and then to the target model.

Casting to \lga{} has been done in a corresponding way.  As a consequence, only even grade terms of a multivector can be cast from the current models to \lga{}.  The objects \texttt{e1\^{}e2\^{}e3\^{}e0} from \pga{} and \texttt{e1\^{}e2\^{}e3\^{}no} from \cga{} and \cbga{}, are algebraically equivalent to \texttt{-e01\^{}e23}, \texttt{-e02\^{}e31} and \texttt{-e03\^{}e12}.  This ambiguity has been resolved by returning the sum of all these three blades, divided by \texttt{3}.

\subsection{Blade interpretation and visualization}
\Autoref{ch:research} discusses several classes of blades with their geometric interpretation.  In this section, the computations of the characteristics needed to draw these blades are given, together with a justification of the visualization.

\TODO{Explain what kind of characteristics one expects to encounter.  Examples:}
\begin{itemize}
  \item Weight, as meant in the homogeneous model.
  \item Location with respect to the origin.  GAViewer uses a certain standardized location on the object, so drawing is made easier.
  \item Direction
  \item Normal
  \item Orthogonal1 to normal and ortho2
  \item Orthogonal2 to normal and ortho1
  \item Pitch
  \item Rotation
  \item Signed radius
\end{itemize}


\comment{Treat implementation of grade 4, 5, 6 in section on 2, 1, 0, resp.?}
\comment{Maybe in start of the higher-level section?}
\subsubsection{Grade 0}
GAViewer does not visualize scalars for the originally implemented models, \ega{}, \pga{}, \cga{}, \cbga{}, and \iga.  With \lga{}, we have decided to follow this example.  It adds a piece of consistency in the interface of the application.  When no explicit casting is done, objects are cast to the simplest model that contains the object.  Scalars are thus identified as part of \ega{}.  When they are cast to \lga{}, it is consistent not to display the object, as no geometric semantics of this element have changed.


\subsubsection{Grade 1}
1-blades can be either a real line, an ideal line or a screw axis.  Each class needs to be interpreted slightly differently.

Real lines have a weight, direction and a location.  The direction vector $\V{d}$ as mentioned in \autoref{sec:plucker} determines the line's orientation.  To determine its direction properly, the software uses the normalized direction $\V{d} / \norm{\V{d}}$.

The location is standardized to be the point closest to the origin of GAViewer's drawing area.  The classical literature on Pl\"ucker coordinates~\cite{Shoemake} presents a way to parameterize the homogeneous points on a line $-\plucker{\V{d}, \V{m}}$.  This parametrization is given by $p(t) = \V{m} \times \V{d} + t \V{d} + \V{d}^2\ez$.  For $t = 0$, the normalized point nearest to the origin is $(\V{m} \times \V{d}) / \V{d}^2$.

For its weight, one cannot take the inner product with itself, as lines are represented by null blades.  Recognizing the repetitious appearance of $\V{d}$ by normalization of the normalized direction and location of the line, it seems reasonable that $\norm{\V{d}}$ will represent the weight.  As current literature has not mentioned weight, the application uses this value.

Real lines are represented similarly to the lines of \pga{}, \cga{} and \cbga{}; a solid line with optional direction marks.  The length of the marks are a visual clue of the weight.

Ideal lines cannot be characterized in this way as $\V{d} = 0$ per definition.  They have no specific location (each point on an ideal line is infinitely far away from any other non-ideal point).  That means that $\V{m}$ represents an ideal line's direction, and $\norm{\V{m}}$ is its norm.

The direction of an ideal line $L$ can be seen as a direct or indirect representation.  Directly, this would give us a line through the origin, in the direction of $\dual{\Em(L)}$, where $\V{d}_{\dual{\Em(L)}} = \edual{\Em(L)}$.  With this representation, ideal lines are displayed the same way as real lines, except that the line is dotted to show the difference. 

In the indirect representation, the ideal line is represented as a circle in $\Em(L)$, where the direction acts as the ideal line's normal.  This agrees with the interpretation of ideal lines as horizons.  The direction is represented by hooks attached on the circle.  Weight can be visualized either by the length of the marks, or by varying the radius of the circle.  To prevent confusion with ``real'' circles of other models and for consistency with the line visualization, the horizon visualization is dotted.

Ideal lines are not represented by the same visualization as \ega's bivectors are, even though they have a more directional aspect than the other vector classes.  This has been done to make clear that these objects represent lines nonetheless, and are fundamentally different from \ega's bivectors, even when an ideal line can be cast to such a bivector.

% Screws!


\subsubsection{Grade 2}
\TODO{Some implemented.  Explain why some not.}


\subsubsection{Grade 3}
\comment{None implemented}

\TODO{Explain why no g3 are implemented}


\subsubsection{Grade 4}
\comment{Fully implemented as dual to grade 2}

\TODO{Explain why pencils of lines are okay to dually draw}

\TODO{Line pair dual\ldots}


\subsubsection{Grade 5}
\comment{Fully implemented as dual to grade 1}


\subsubsection{Grade 6}
The originally implemented models show a slight inconsistency for visualization of their pseudoscalar.  While GAViewer displays a transparant sphere for \ega{}'s pseudoscalar, the other models display nothing.  Again, we have chosen for consistency.  By duality to scalars, it is safe to say that the semantics of the pseudoscalar have not changed.
