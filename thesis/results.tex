\section{Implementation}
\label{ch:implementation}
\TODO{Introductory text.}
With the knowledge of the frameworks acquired in \autoref{ch:background} and \autoref{ch:research}, we now can extend the functionality of GAViewer.  The following parts will discuss the following subjects: how GAViewer can be extended, and how it has been done;  the origins of the software for computing with the Pl\"ucker model;  how casting from and to the Pl\"ucker model is realized;  and, lastly, the visualization of each provided element is explained.


\subsection{Software design decision}
\label{sec:softwaredesign}
Extending GAViewer's functionalities can be done in two ways.  

Since version 0.4, GAViewer can open a TCP port for communication with other programs~\cite{GAViewer}.  The extended functionality can be implemented by a program that maintains an own interface for user input.  The input will be sent to GAViewer over a TCP port, after it has been processed by the new application.  Textual results are returned over the TCP port, and thus can be shown in the application's own user interface.  However, the visualization of the elements will be shown in GAViewer's own viewport.  The user has to switch between user interfaces to view textual or visual representations, which the user probably experiences as confusing or annoying.  To show the new model's blades correctly, it should be possible to characterize their visualization in terms of elements of other models, and elements of those models should be passed around between the new program and GAViewer.  This limitation seems undesired for our elements; no supported model has primitives that can make up a screw axis' visualization.  

Users might still interact with the drawn elements in GAViewer.  This means that their transformations will have to be translated to corresponding transformations of our model.  All objects, like a pencil of lines, will have to be drawn by a set of elements of an existing model.  This complexity grows when such elements of the new model are declared dynamic; a whole net of interdependencies arises.  We would rather avoid code complexity, as that often gives rise to bugs.

The C++ source code of GAViewer is freely available on the internet\footnote{The source code of GAViewer can be downloaded from \url{http://geometricalgebra.net/gaviewer\_download.html}.}.  This means that GAViewer could also be extended by adding the new functionality in the original source code, and compile it all together to form a unified piece of software.  Because there is very little documentation in the source code on how to extend the functionality of GAViewer with a new model, an old model that has gone out of use might be replaced with our new one.  With a textual search through the source code, it will be possible to find all hooks for adding the right functionality.  

The problems that arose from extension through an external implementation do not apply.  The unified user interface can be taken for granted.  User interaction and dynamic statement management are all implemented independent from the models.  Only the transformation resulting in the new object when dragged has to be implemented once.  This is easy to do for all elements, because our model is operational.  New graphical elements can be made when needed, because calls to OpenGL routines can be made. 

We have decided to remove the model for \iga{} and substitute it with our new model, named \lga{}.  No element of \iga{} currently has visualizations and after a short interview, interest in \iga{} within the user base of GAViewer has dropped.

\subsection{Computing with \lga{} in GAViewer}
GAViewer relies on code generated by Gaigen for the implementation of each model~\cite{Gaigen}.  Although more recent versions of Gaigen, such as version 2.5, have a better performance, the code for \lga{} has been generated by the same version of Gaigen, version 1.0, which generated the other models as well.  This has three reasons.  The API of more recent versions are not compatible with the API of the version used by the application.  The documentation of GAViewer states that it is inappropriate to use GAViewer in applications that need good performance, as the internal, interpreted programming language is too slow and limited~\cite[page 7]{GAViewer}.  Therefore, performance improvements in only a model would not suffice to make the program more useful.  Furthermore, the used implementations are fast enough to handle hand-typed expressions without any noticeable delay for the user.

\subsection{Models and casting}
The geometric interpretation of an object of geometric algebra is based on its model.  When an expression is evaluated without any explicit model specifier, GAViewer will try to evaluate it in the model of \ega{} first.  If the expression contains terms of a different model, GAViewer automatically applies the appropriate model.  In case there are terms that cannot be interpreted in any model, those evaluate to \texttt{0}.

GAViewer has support for casting objects from one model to another.  Multivectors are expressed on the source model's basis, and corresponding basis vectors of the target model are multiplied by the source model's factors.  For example, the expression \texttt{3.00*e1\^{}e5 + 0.50*e3\^{}no} evaluates to an object of model \cbga{}.  When cast to \cga{} it evaluates to \texttt{0.50*e3\^{}no}, as \cga{} only knows \texttt{e1}, \texttt{e2}, \texttt{e3}, \texttt{no}, and \texttt{ni}.  Casting to \pga{}, results in \texttt{0.50*e3\^{}e0}, because \texttt{no} and \texttt{e0} have corresponding semantics.  Casting to \ega{} results in \texttt{0}, as both \texttt{e1\^{}e5} and \texttt{e3\^{}no} can be interpreted in the model.

The casting from \lga{} to \pga{} has been implemented in the same way as expressions from the Pl\"ucker model are embedded in the homogeneous model through the embedding function $\Em$, defined in \autoref{eq:Em}.  The casting to other models is equivalent to casting to \pga{}, and then to the target model.

Casting to \lga{} has been done in a corresponding way.  As a consequence, only even grade terms of a multivector can be cast from the current models to \lga{}.  The objects \texttt{e1\^{}e2\^{}e3\^{}e0} from \pga{} and \texttt{e1\^{}e2\^{}e3\^{}no} from \cga{} and \cbga{}, are algebraically equivalent to \texttt{-e01\^{}e23}, \texttt{-e02\^{}e31} and \texttt{-e03\^{}e12}.  This ambiguity has been resolved by returning the sum of all these three blades, divided by \texttt{3}.

\subsection{Blade interpretation and visualization}
\begin{table}
  \caption{GAViewer uses colors to encode the grade of the object.}
  \label{tab:gradecolor}
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      Grade & Color \\
      \hline
      \hline
      0 & Black \\
      1 & Red \\
      2 & Blue \\
      3 & Green \\
      4 & Yellow \\
      5 & White \\
      6 & Red \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

\Autoref{ch:research} discusses several classes of blades with their geometric interpretation.  In this section, the computations of the position and stance of these blades in 3D space are given, together with a motivation for the chosen visualization.  

GAViewer provides user controlled switches for visualizing the object's orientation and weight.  How these properties of the object are displayed is discussed as well.

In the visualization, the grade of the object is shown through usage of certain colors.  This association of color and grade is given in \autoref{tab:gradecolor}.  Note that grade 1 and grade 6 objects share the same color; during the original design of GAViewer, no grade 6 objects were expected to be visualized.

\subsubsection{Grade 0}
GAViewer does not visualize scalars for the originally implemented models, \ega{}, \pga{}, \cga{}, \cbga{}, and \iga.  With \lga{}, we have decided to follow this example.  It adds a piece of consistency in the interface of the application.  When no explicit casting is done, objects are cast to the simplest model that contains the object.  Scalars are thus identified as part of \ega{}.  When they are cast to \lga{}, it is consistent not to display the object, as no geometric semantics of this element have changed.


\subsubsection{Grade 1}
1-blades can be either a real line, an ideal line or a screw axis.  Each class needs to be interpreted slightly differently.

\paragraph{Real line}
Real lines have a weight, orientation and a location.  The direction vector $\V{d}$ as mentioned in \autoref{sec:plucker} determines the line's orientation.  To determine its orientation properly, the software uses the normalized direction $\V{d} / \norm{\V{d}}$.

The location is standardized to be the point closest to the origin of GAViewer's drawing area.  The classical literature on Pl\"ucker coordinates~\cite{Shoemake} presents a way to parameterize the homogeneous points on a line $-\plucker{\V{d}, \V{m}}$.  This parametrization is given by $p(t) = \V{m} \times \V{d} + t \V{d} + \V{d}^2\ez$.  For $t = 0$, the normalized point nearest to the origin is $(\V{m} \times \V{d}) / \V{d}^2$.

Real lines are represented similarly to the lines of \pga{}, \cga{} and \cbga{}; a solid line with optional orientation marks.  The length of the marks are a visual clue of the weight.  Although the mathematical object is infinitely long, the length of the lines drawn are limited by a constant, internally defined in GAViewer.

\paragraph{Ideal line}
Ideal lines cannot be characterized in this way as $\V{d} = 0$ per definition.  They have no specific location (each point on an ideal line is infinitely far away from any other non-ideal point).  That means that $\V{m}$ represents an ideal line's orientation.

The orientation of an ideal line $L$ can be seen as a direct or indirect representation.  Directly, this would give us a line through the origin, in the direction of $\dual{\Em(L)}$, where $\V{d}_{\dual{\Em(L)}} = \edual{\Em(L)}$.  With this representation, ideal lines are displayed the same way as real lines, except that the line is dotted to show the difference. 

In the indirect representation, the ideal line is represented as a circle in $\Em(L)$, where the orientation acts as the ideal line's normal.  This agrees with the interpretation of ideal lines as horizons.  The orientation is represented by hooks attached on the circle.  Weight can be visualized either by the length of the marks, or by varying the radius of the circle.  To prevent confusion with ``real'' circles of other models and for consistency with the line visualization, the horizon visualization is dotted.

Ideal lines are not represented by the same visualization as \ega's bivectors are, even though they have a more directional aspect than the other vector classes.  This has been done to make clear that these objects represent lines nonetheless, and are fundamentally different from \ega's bivectors, even when an ideal line can be cast to such a bivector.

\paragraph{Screw axis}
The axes of screw motions have two visualizations.  By default, only one period is shown.  The screw axis is shown as a spiral, with its pitch determining the length of the spiral.  With a positive pitch, the spiral performs a right-handed rotation.  In case of a negative pitch, the spiral is left-handed.  The orientation of the screw axis is given by the orientation of its axis (see \autoref{eq:screwparams}), and visually represented by a vector's arrow head on the corresponding end of the spiral.  
Its weight can be shown visually by the radius of the spiral.

As an alternate visualization, the user can choose to show a whole column of joined spirals.

\subsubsection{Grade 2}
The visualization of the pencil of linear line complexes, and the hyperbolic pencil of linear complexes are provided. 

\paragraph{Pencil of linear line complexes}

\paragraph{Hyperbolic pencil of linear complexes}



\subsubsection{Grade 3}
\comment{None implemented}

\TODO{Explain why no g3 are implemented}


\subsubsection{Grade 4}
Just as their duals, the dual pencil of linear line complexes as well as the hyperbolic linear congruence are provided with visualizations.
%The visualization of the parabolic linear congruence and the elliptic linear congruence are not implemented.

\paragraph{Dual pencil of linear line complexes}
Pottmann and Wallner show that the dual of a pencil of linear line complexes contains the same lines as its direct representation~\cite[Section 3.2.1]{Pottmann}.  Therefore, the computations needed for the visualizations are done with the dual element.  The visual representation is equivalent to that of the grade 2 element.

\paragraph{Hyperbolic linear congruence}
The location and orientation of a hyperbolic linear congruence is also computed with its dual, a pair of skew lines.  The visualization shows a sample of the direct representation of the four-blade.  The sample takes 31 evenly spaced points on both lines of its dual, and connects them.  The lines are not drawn with the same length as the grade 1 lines.  We believe that this amount of long lines clutter the interface and obscures the geometrical structure of the object.  The line pieces are only drawn from a point from one line to a point on the other line.

The orientation of this congruence is defined as the orientation of its dual.  When the orientation is shown, the line pieces are replaced with vector objects, pointing in the same direction as the single vector points in the case of the dual.

\subsubsection{Grade 5}
Five-blades are visualized in the same way as their duals.  Vectors represent the axis of the motion of a grade 5 object, and thus can give a good visual indication of the nature of the motion itself.

\subsubsection{Grade 6}
The originally implemented models show a slight inconsistency for visualization of their pseudoscalar.  While GAViewer displays a transparant sphere for \ega{}'s pseudoscalar, the other models display nothing.  As in the scalar case, we have chosen for consistency.  By duality to scalars, it is safe to say that the semantics of the pseudoscalar have not changed.
