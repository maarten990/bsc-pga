\section{Implementation}
\label{ch:implementation}
With the knowledge of the frameworks acquired in \autoref{ch:background} and \autoref{ch:research}, we now can extend the functionality of GAViewer.  The following parts will discuss the following subjects: how GAViewer can be extended, and how it has been done;  the origins of the software for computing with the Pl\"ucker model;  how casting from and to the Pl\"ucker model is realized;  and, lastly, the visualization of each provided element is explained.


\subsection{Software design decision}
\label{sec:softwaredesign}
Extending GAViewer's functionalities can be done in two ways.  

Since version 0.4, GAViewer can open a TCP port for communication with other programs~\cite{GAViewer}.  The extended functionality can be implemented by a program that maintains an own interface for user input.  The input will be sent to GAViewer over a TCP port, after it has been processed by the new application.  Textual results are returned over the TCP port, and thus can be shown in the application's own user interface.  However, the visualization of the elements will be shown in GAViewer's own viewport.  The user has to switch between user interfaces to view textual or visual representations, which the user probably experiences as confusing or annoying.  To show the new model's blades correctly, it should be possible to characterize their visualization in terms of elements of other models, and elements of those models should be passed around between the new program and GAViewer.  This limitation seems undesired for our elements; no supported model has primitives that can make up a screw axis' visualization.  

Users want to interact with the drawn elements in GAViewer.  This means that their transformations will have to be translated to corresponding transformations of our model.  All objects, like a pencil of lines, will have to be drawn by a set of elements of an existing model.  This complexity grows when such elements of the new model are declared dynamic; a whole net of interdependencies arises.  We would rather avoid code complexity, as that often gives rise to bugs.

The C++ source code of GAViewer is freely available on the internet\footnote{The source code of GAViewer can be downloaded from \url{http://geometricalgebra.net/gaviewer\_download.html}.}.  This means that GAViewer could also be extended by adding the new functionality in the original source code, and compile it all together to form a unified piece of software.  Because there is very little documentation in the source code on how to extend the functionality of GAViewer with a new model, an old model that has gone out of use might be replaced with our new one.  With a textual search through the source code, it is possible to find all hooks for adding the right functionality.  

The problems that arose from extension through an external implementation do not apply.  The unified user interface can be taken for granted.  User interaction and dynamic statement management are all implemented independent from the models.  Only the transformation resulting in the new object when dragged has to be implemented once.  This is easy to do for all elements, because our model is operational.  New graphical elements can be made when needed, because calls to OpenGL routines can be made. 

We have decided to remove the existing 6D model for \iga{} and substitute it with our new model, named \lga{}.  No element of \iga{} currently has visualizations and after a short interview, interest in \iga{} within the user base of GAViewer has dropped.  The original developer warned that adding a new model might raise unknown bugs; although the program has been made with the idea that it might be extended some day, it has not been thoroughly tested or documented.

\subsection{Computing with \lga{} in GAViewer}
GAViewer relies on code generated by Gaigen for the implementation of each model~\cite{Gaigen}.  Although more recent versions of Gaigen, such as version 2.5, have a better performance, the code for \lga{} has been generated by the same version of Gaigen, version 1.0, which generated the other models as well.  This has three reasons.  The API of more recent versions are not compatible with the API of the version used by the application.  The documentation of GAViewer states that it is inappropriate to use GAViewer in applications that need good performance, as the internal, interpreted programming language is too slow and limited~\cite[page 7]{GAViewer}.  Therefore, performance improvements in only a model would not suffice to make the program more useful.  Furthermore, the used implementations are fast enough to handle hand-typed expressions without any noticeable delay for the user.

\subsection{Models and casting}
The geometric interpretation of an object of geometric algebra is based on its model.  When an expression is evaluated without any explicit model specifier, GAViewer will try to evaluate it in the model of \ega{} first.  If the expression contains terms of a different model, GAViewer automatically applies the appropriate model.  In case there are terms that cannot be interpreted in any model, those evaluate to \texttt{0}.

GAViewer has support for casting objects from one model to another.  Multivectors are expressed on the source model's basis, and corresponding basis vectors of the target model are multiplied by the source model's factors.  For example, the expression \texttt{3.00*e1\^{}e5 + 0.50*e3\^{}no} evaluates to an object of model \cbga{}.  When cast to \cga{} it evaluates to \texttt{0.50*e3\^{}no}, as \cga{} does not have a vector that has similar semantics to \texttt{e5}.  Casting to \pga{} results in \texttt{0.50*e3\^{}e0}, because the semantics of \texttt{no} and \texttt{e0} correspond; both represent an arbitrarily chosen origin.  Casting to \ega{} results in \texttt{0}, as both \texttt{e1\^{}e5} and \texttt{e3\^{}no} cannot be interpreted in the model.

The casting from \lga{} to \pga{} has been implemented in the same way as expressions from the Pl\"ucker model are embedded in the homogeneous model through the embedding function $\Em$, defined in \autoref{eq:Em}.  The casting to other models is equivalent to casting to \pga{}, and then to the target model.

Casting to \lga{} has been done in a corresponding way.  As a consequence, only even grade terms of a multivector can be cast from the current models to \lga{}.  The objects \texttt{e1\^{}e2\^{}e3\^{}e0} from \pga{} and \texttt{e1\^{}e2\^{}e3\^{}no} from \cga{} and \cbga{}, are algebraically equivalent to \texttt{-e01\^{}e23}, \texttt{-e02\^{}e31} and \texttt{-e03\^{}e12}.  This ambiguity has been resolved by returning the sum of all these three blades, divided by \texttt{3}.  In addition, a warning text is presented to the user, stating this.

\subsection{Blade interpretation and visualization}
\begin{table}
  \caption{GAViewer uses colors to encode the grade of the object.}
  \label{tab:gradecolor}
  \begin{center}
    \begin{tabular}{|l|l|}
      \hline
      Grade & Color \\
      \hline
      \hline
      0 & Black \\
      1 & Red \\
      2 & Blue \\
      3 & Green \\
      4 & Yellow \\
      5 & White \\
      6 & Red \\
      \hline
    \end{tabular}
  \end{center}
\end{table}

\Autoref{ch:research} discusses several classes of blades with their geometric interpretation.  In this section, the computations of the position and stance of these blades in 3D space are given, together with a motivation for the chosen visualization.  

GAViewer provides user controlled switches for visualizing the object's orientation and weight.  How these properties of the object are displayed is discussed as well.

In the visualization, the grade of the object is shown through usage of certain colors.  This association of color and grade is given in \autoref{tab:gradecolor}.  Note that grade 1 and grade 6 objects share the same color; during the original design of GAViewer, no grade 6 objects were expected to be visualized.

\subsubsection{Grade 0}
GAViewer does not visualize scalars for the originally implemented models, \ega{}, \pga{}, \cga{}, \cbga{}, and \iga.  With \lga{}, we have decided to follow this example.  It adds a piece of consistency in the interface of the application.  When no explicit casting is done, objects are cast to the simplest model that contains the object.  Scalars are thus identified as part of \ega{}.  When they are cast to \lga{}, it is consistent not to display the object, as no geometric semantics of this element have changed.


\subsubsection{Grade 1}
1-blades can be either a real line, an ideal line or a screw axis.  Each class needs to be interpreted slightly differently.

\paragraph{Real line}
Real lines have a weight, orientation and a location.  The direction vector $\V{d}$ as mentioned in \autoref{sec:plucker} determines the line's orientation.  To determine its orientation properly, the software uses the normalized direction $\V{d} / \norm{\V{d}}$.

The location is standardized to be the point closest to the origin of GAViewer's drawing area.  The classical literature on Pl\"ucker coordinates~\cite{Shoemake} presents a way to parameterize the homogeneous points on a line $-\plucker{\V{d}, \V{m}}$.  This parametrization is given by $p(t) = \V{m} \times \V{d} + t \V{d} + \V{d}^2\ez$.  For $t = 0$, the normalized point nearest to the origin is $(\V{m} \times \V{d}) / \V{d}^2$.

Real lines are represented similarly to the lines of \pga{}, \cga{} and \cbga{}; a solid line with optional orientation marks.  The length of the marks are a visual clue of the weight.  Although the mathematical object is infinitely long, the length of the lines drawn are limited by a constant, internally defined in GAViewer.

\paragraph{Ideal line}
Ideal lines cannot be characterized in this way as $\V{d} = 0$ per definition.  They have no specific location (each point on an ideal line is infinitely far away from any other non-ideal point).  That means that $\V{m}$ represents an ideal line's orientation.

The orientation of an ideal line $L$ can be seen as a direct or indirect representation.  Directly, this would give us a line through the origin, in the direction of $\dual{\Em(L)}$, where $\V{d}_{\dual{\Em(L)}} = \edual{\Em(L)}$.  With this representation, ideal lines are displayed the same way as real lines, except that the line is dotted to show the difference. 

In the indirect representation, the ideal line could be represented as a circle on the celestical sphere, where the orientation acts as the ideal line's normal.  This agrees with the interpretation of ideal lines as horizons.  However, it is hard to make clear for the user that the circle is indeed on the celestial sphere, when other elements are not.  To eliminate confusion with genuine finite circles, which would otherwise be drawn similar, GAViewer draws celestial circles as a dotted finite circle at the origin.  The orientation is represented by hooks attached on the circle.  Weight can be visualized either by the length of the marks, or by varying the radius of the circle.

Ideal lines are not represented by the same visualization as \ega's bivectors are, even though they have a more directional aspect than the other vector classes.  This has been done to make clear that these objects represent lines nonetheless, and are fundamentally different from \ega's bivectors, even when an ideal line can be cast to such a bivector.

\paragraph{Screw axis}
The axes of screw motions have two visualizations.  By default, only one period is shown.  The screw axis is shown as a spiral, with its pitch determining the length of the spiral.  With a positive pitch, the spiral performs a right-handed rotation.  In case of a negative pitch, the spiral is left-handed.  The orientation of the screw axis is given by the orientation of its axis (see \autoref{eq:screwparams}), and visually represented by a vector's arrow head on the corresponding end of the spiral.  
Its weight can be shown visually by the radius of the spiral.

As an alternate visualization, the user can choose to show a whole column of joined spirals.

\subsubsection{Grade 2}
The visualization of the pencil of linear line complexes, and the hyperbolic pencil of linear complexes are provided. 

\paragraph{Pencil of linear line complexes}
Pencils of real, not parallel lines are visualized as a sample of the lines contained by the blade.  For the pencil of real lines $B = a \wedge b$, 64 evenly distributed line pieces of length $w(B)$ are drawn that intersect at the center of $B$.  We have chosen to limit the sample to this number of line pieces, as the interface might get cluttered.  We draw line pieces instead of full lines with the same reason.  If the user desires to have the orientation visualized, the line pieces are replaced with four times fewer vectors of the same length.  For a positive orientation, the vectors point to the center.  For a negative orientation, the vectors point the other way.

In case of a pencil of real, parallel lines, a set of parallel lines in direction $\V{D} = (\Em(a) \lcont -\ez) \wedge (\Em(b) \lcont -\ez)$ are drawn.  This set has the same dimensions as the implemented visualization of a plane.  Given the width of the drawn plane $w$, $5w$ lines are drawn.  Weight and orientation are drawn in the same way as it is drawn for planes; normal lines appear on one side of the pencil, their direction representing the orientation, and their length representing the weight.

When the pencil contains only ideal lines, 32 evenly distributed ideal lines in the horizon representation are drawn.  These result in a set of rotated circles.  If the orientation is displayed, a vector is drawn on either of the intersection of the circles, pointing at the other intersection.

\paragraph{Hyperbolic pencil of linear complexes}
The 2-blade of two lines that are not coplanar contains only these two lines.  We only draw these two lines for their visualization.  These lines can be both real, or one real and one ideal.  To indicate the orientation in the case of two real lines, a vector is drawn between the points nearest to the origin of both lines, as well as the hooks that are default for lines.  If the blade contains one real and one ideal line, only the hooks are displayed.  

The weight is visualized by the size of the hooks.


\subsubsection{Grade 3}
We have implemented visualization routines for the points, planes and the couple-wheel pencils.  As we have not analyzed the reguli, we do not supply visualization routines.

\paragraph{Point} 
We draw the blades of three concurrent points with the same routines as points of the homogeneous and conformal models.  Consistent with the points of other models, the orientation is not visualized.  Its weight is visualized through the size of the point.

An ideal point is visualized as a pair of dotted points.  When the user wants to see the orientation, a dotted vector is drawn from one point to the other.  The user is informed of the ideal point's weight by the distance between the two graphical points.

\paragraph{Plane} 
The visual representation of planes of the Pl\"ucker model is generated in the same way as for planes in other models.  When required by the user, the weight is represented by the length of normal lines on one side of the plane.  The side chosen is determined by its orientation. 

Because we can see the ideal plane as the celestial sphere, we draw it as a dotted sphere.  The weight is represented by the sphere's radius, while its orientation is represented in the same way as it is done for the real plane.  This visualization equals that of the Euclidean trivector, which is another interpretation of the ideal plane.

\paragraph{Couple-wheel pencil}
The couple-wheel pencil is visualized by the visualization of its two pencils, joined together with a line piece between the two centers.  The weight is visualized through the length of the line pieces of the two pencils.  When the orientation should be visualized, the line piece representing the common line is replaced by a vector.

\subsubsection{Grade 4}
Just as their duals, the dual pencil of linear line complexes as well as the hyperbolic linear congruence are provided with visualizations.
%The visualization of the parabolic linear congruence and the elliptic linear congruence are not implemented.

\paragraph{Dual pencil of linear line complexes}
Pottmann and Wallner show that the dual of a pencil of linear line complexes contains the same lines as its direct representation~\cite[Section 3.2.1]{Pottmann}.  Therefore, the computations needed for the visualizations are done with the dual element.  The visual representation is equivalent to that of the grade 2 element.

\paragraph{Hyperbolic linear congruence}
The location and orientation of a hyperbolic linear congruence is also computed with its dual, a pair of skew lines.  The visualization shows a sample of the direct representation of the 4-blade.  The sample takes 31 evenly spaced points on both lines of its dual, and connects them.  The lines are not drawn with the same length as the grade 1 lines.  We believe that this amount of long lines clutter the interface and obscures the geometrical structure of the object.  The line pieces are only drawn from a point from one line to a point on the other line.

The orientation of this congruence is defined as the orientation of its dual.  When the orientation is shown, the line pieces are replaced with vector objects, pointing in the same direction as the single vector points in the case of the dual.

\subsubsection{Grade 5}
5-blades are visualized in the same way as their duals.  Vectors represent the axis of the motion of a grade 5 object, and thus can give a good visual indication of the nature of the motion itself.

\subsubsection{Grade 6}
The originally implemented models show a slight inconsistency for visualization of their pseudoscalar.  While GAViewer displays a transparant sphere for \ega{}'s pseudoscalar, the other models display nothing.  As in the scalar case, we have chosen for consistency with the largest number of models supplied, and do not draw the pseudoscalar.  By duality to scalars, it is safe to say that the semantics of the pseudoscalar have not changed.

\subsection{User interaction}
For the original models, most visualizations of objects in GAViewer can be dragged with a right mouse click while holding the \texttt{Ctrl} key down.  The objects that can be translated, are translated corresponding to the mouse's movement.  Objects that are translation invariant, are rotated accordingly.  Objects that are invariant under translation and rotation, such as the Euclidean trivector, are only scaled.  Besides rotating, Euclidean vectors are scaled as well.

We have implemented this part of the user interaction for our model.  The real lines, screws, pencils of real lines, line pairs, real points, real planes and couple-wheel pencils are translated.  Ideal lines, pencils of ideal lines are rotated, as their geometric interpretation has no location.  The ideal plane is scaled in the same way the Euclidean trivector is.  

We have used the translation and rotation versors presented in an internal report~\cite{internal}.  Translation over $\V{t} = \tau_1\ee + \tau_2\et + \tau_3\ed$ is performed by the versor $T_\V{t}$: 
\begin{equation*}
  T_\V{t} = \exp(\frac{1}{2} (\tau_1 \eet \wedge \ede + \tau_2 \etd \wedge \eet + \tau_3 \ede \wedge \etd)) . 
\end{equation*}
Clockwise rotation in the bivector plane $\V{R} = \rho_1 \et\ed + \rho_2\ed\ee + \rho_3\ee\et$ around the origin over $\weight(\V{R})$ radians is performed by $R_\V{R}$:
\begin{equation*}
  R_\V{R} = \exp(\frac{1}{2} (\rho_1 (\ezt \wedge \eet - \ezd \wedge \ede) + \rho_2 (\ezd \wedge \etd - \eze \wedge \eet) + \rho_3 (\eze \wedge \ede - \ezt \wedge \etd))) .
\end{equation*}
